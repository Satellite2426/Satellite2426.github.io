# Java 基础

## Java 入门简介

Java技术体系又可以主要分为以下3个平台。

**1.Java SE**

Java Standard Edition，即Java标准版。主要是Java技术的核心和基础，要想学好Java，那么首先你得掌握好这部分。主要运行在桌面级应用，如Windows应用程序。

**2.Java EE**

Java Enterprise Edition，即Java企业版。从它的名字就不难看出，这是Java针对企业级应用开发所提供的一套解决方案，主要用于架设高性能企业网站。

**3.Java ME**

Java Micro Edition，即Java小型版。主要是针对移动设备应用所提供的一套解决方案，主要运行在手机、pad等移动端。

## JDK 安装及入门实例

安装好JDK之后，打开安装路径，通常情况下会有如下的目录结构：

|  目录   |                                                              |
| :-----: | ------------------------------------------------------------ |
|   bin   | 用于存放各种工具命令，比如我们最常用的javac、java等          |
|   lib   | 存放工具的一些补充 jar 包                                    |
|  conf   | 存放相关配置文件                                             |
| include | 存放一些平台特定的头文件，比如 Windows、 macOS、 Linux平台下这里的头文件是有所不同的 |
|  legal  | 存放各模板的授权文件                                         |
|  jmods  | 存放各种模块                                                 |

**HelloWorld**：

```java
public class Main{
    public static void main(String[] args){
        System.out.println("Hello World!");
    }
}
```

`public`：权限修饰符，表示这一个可以公开访问的类，类似的还有 `protected、default、private`；

`class`：Java 关键字，表示这是一个类；

`Main`：表示我们的类名，在保存时文件一定要和它同名，否则你的程序时编译不了的；

`public static void main(String[] args){}`：主方法，这是我们以后最常接触到的一个方法，每个主类当中都必须有一个`main`方法；

`System.out.println("Hello World!")`：控制台输出语句，执行该语句会在控制台中输出字符串，字符串要用双引号`""`括起来。

**开发工具：Intellij IDEA**

项目创建成功后，在项目 `src`  目录上右键新建一个 Java 类文件。注意，一般来讲，我们倾向于把类的命名方式定义为首字母大写的驼峰命名法。

## 变量与数据类型

### **1.变量**

变量，就是用来命名一个数据的标识符，其定义格式如下：

```java
数据类型 变量名称 = 初始值;
```

数据类型是用于限制存储数据的形式；变量名称是用于代表变量的一个符号；初始值则代表该变量存储时的初始数据。

在 Java 中，变量主要分为两种：

- 基本类型的变量
- 引用类型的变量

```java
// 基本类型的变量
int id = 1;
// 引用类型的变量
String name = "晁诗涵";
```

其中 `int` 是基本数据类型，表示这个是一个整型数；而 `String` 则是引用类型，表示这是一个引用类型；`id` 和 ~ 是变量； `=` 则是赋值操作符，而 1 则是基本类型的值，`晁诗涵` 则是引用类型的值。

### **2.变量的特点**

在使用变量时，需要注意以下几个问题：

1.变量一定要先声明再使用

2.声明一个变量的类型后，不能用它来存储其它类型的数据

3.变量定义时可以不赋初始值，但是在使用时必须赋值

4.变量是有使用范围的，在同一使用范围内，不能重复定义同一个变量

5.变量最重要的一个特点就是可以重新赋值

### **3.变量命名规则**

变量命名也是一门学问，并不是我们想怎么命名就怎么命名，日常开发中最常见的变量命名规则主要有如下几条：

1.**强制**：变量命名只能使用字母（大小写均可）、数字、$、_

2.**强制**：变量名不能使用关键字（就是 Java 中内置的一些关键字，如 int、for、long...）

3.**强制**：变量第一个字符不能使用数字，只能使用字母、$、_

###  **4.常见关键字**

这是一种事先定义好的、有特定意义的标识符，也叫做保留字。对于 Java 编译器有着特殊意义，用来表示一种数据类型，或者表示程序的结构等。此外，关键字不能用作变量名、方法名、类名、包名和参数名。常见的关键字可以分为如下几类，具体的关键字如图所示：

- **访问控制类**
- **类、方法及变量修饰符类**
- **程序控制类**
- **错误处理**
- **包相关**
- **基本类型**
- **变量引用**
- **保留字**

**![image-20230811092300812](https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308110923922.png)**

### 5.数据类型

**1.基本数据类型**

Java 中，共有8中基本数据类型，由 Java 语言预定好的，每个数据类型都属于关键字，而且每种基本变量都有其对应的封装类，这 8 中基本数据类型分别是：

- **整型（4种）**
- **浮点型（2种）**
- **字符型（1种）**
- **布尔型（1种）**

| 数据类型 | bit  |  字节  |  封装类   |
| :------: | :--: | :----: | :-------: |
|   byte   |  8   |   1    |   Byte    |
|  short   |  16  |   2    |   Short   |
|   char   |  16  |   2    | Character |
|   int    |  32  |   4    |  Integer  |
|   long   |  64  |   8    |   Long    |
|  float   |  32  |   4    |   Float   |
|  double  |  64  |   8    |  Double   |
| boolean  |  1   | 不确定 |  Boolean  |

**2.引用数据类型**

**常见引用数据类型**

| 数据类型 | 默认值 |
| :------: | :----: |
|   数组   |  null  |
|    类    |  null  |
|   接口   |  null  |

对于引用数据类型，我们经常是需要 `new` 关键字来进行赋值，但是引用类型中的接口是不能被实例化的，我们需要对其进行实现：

```java
// 初始化一个对象
Pet dog = new Pet();
// 初始化一个数组
int[] arr = new int[10];
```

**String**

String 不同于 char ，它属于引用类型，而 char 属于基本数据类型。用双引号 "" 括起来表示字符串，一个字符串能够保存0个到任意个字符，它一旦创建就不能被改变。

而针对字符串，如果我们要打印一些特殊的字符，比如字符串本身就包含 " ，那么这个时候就需要借助于转义字符 \ ，最常见的转义字符主要有：

| 转移字符 |    含义    |
| :------: | :--------: |
|   `\"`   |   字符 "   |
|   `\'`   |   字符 '   |
|   `\\`   |   字符 \   |
|   `\n`   |   换行符   |
|   `\t`   | 制表符 Tab |
|   `\r`   |   回车符   |

Java 编译器中，对于字符串和其他数据类型之间，可以使用 `+` 进行连接，编译器会自动将其他数据嘞型自动转换为字符串，然后再进行连接。

**3.数据类型转换**

对于基本数据类型，不同类型之间是可以相互转换的，但是需要满足一定的条件。

> 从小到大自动转，从大到小强制转

即，对于低精度的数据类型，如果要转换为高精度的数据类型，直接将低精度的值赋给高精度的值即可。

**隐式转换（自动类型转换）**

当满足如下条件时，如果将一种类型的数据赋值给另一种数据类型变量时，将执行自动类型转换：

> 1. 两种数据类型彼此兼容；
>
> 2. 目标数据类型的取值范围大于源数据类型

一般而言，隐式转换的规则是从低级类型数据转换为高级类型数据，对应规则如下：

> **数值类型**：`byte -> short -> int -> long -> float -> double`
>
> **字符类型转整型**：`char -> int`

**显式转换（强制类型转换）**

显式转换的概念相对于隐式转换，其语法格式如下：

```java
(type) variableName;
```

举例说明：

```java
int num = 3;
double ans = 5.0;
// 要将 double 类型的值赋值给 int，则需要强制转换
num = (int)ans;
```

**注意**：强制转换可能会导致精度丢失，所以一般情况下精良能不用就不用

1. **字符串与其他类型之间的转换**

- **其他类型 -> 字符串**

> 1. 调用类的串转换方法：`X.toString()`;
> 2. 自动转换：`"" + X`;
> 3. 利用 `String` 的方法：`String.valueOf(X)`;

```java
// 方法 1
String str1 = Integer.toString(int num);
String str2 = Long.toString(long num);
String str3 = Float.toString(flaot num);
String str4 = Double.toString(double num);

// 方法 2
String str = "" + num ; // num 是 int、long、float、double 类型

// 方法 3
String str1 = String.valueOf(int num);
String str2 = String.valueOf(long num);
String str3 = String.valueOf(float num);
String str4 = String.valueOf(double num);
```

- **字符串 -> 其他类型**

> 1. 调用 `parseXXX` 方法，比如 `parseLong、parseFloat、parseDouble...`；
> 2. 先调用 `valueOf()` 方法，然后再调用 `xxxValue()` 方法；

```java
// 方法 1
int num1 = Integer.parseInt(String str);
Long num2 = Long.parseLong(String str);
Float num3 = Float.parseFloat(String str);
Double num4 = Double.parseDouble(String str);

// 方法 2
int num1 = Integer.valueOf(String str).intValue();
Long num2 = Long.valueOf(String str).longValue();
Float num1 = Float.valueOf(String str).floatValue();
Double num1 = Double.valueOf(String str).doubleValue();
```

2. **int、float、double之间的转换**

- `float -> double`

```java
float num = 1.0f;
Float num1 = new Float(num);
double num2 = num1.doubleValue();
```

- `double -> float`

```java
double num = 100.0;
float num1 = (float)num;
```

- `double -> int`

```java
double num = 100.0;
Double num1 = new Double(num);
int num2 = num1.intValue();
```

- `int -> double`

```java
int num = 200;
double num1 = num;
```

### 6.变量作用域

一般根据变量作用域的不同，可以分为：

- **成员变量**：定义在方法体和语句块外，不属于任何一个方法，能在整个类中起作用；
- **局部变量**：定义在方法或方法体中的变量，作用域是在其所在的代码块；

**成员变量**

成员变量又可以分为全局变量（又叫实例变量）和静态变量（也叫类变量），两者的区别如下：

|   名称   |  修饰符  |    访问方式    |                  生命周期                  |
| :------: | :------: | :------------: | :----------------------------------------: |
| 全局变量 |    无    | 对象名，变量名 |      一旦对象被引用，则实例变量就存在      |
| 静态变量 | `static` |  类名，变量名  | 同类共生死，只有当类被 GC 回收时才会被销毁 |

```java
public class Person {
    // 成员变量，全局变量
    String name;
    // 成员变量，全局变量
    int age;

    // 成员变量，静态变量
    public static final String wechatPublic = "晁诗涵";
    // 成员变量，静态变量
    public static final String website = "http://cunyu1943.site";
}
```

**局部变量**

局部变量指定义在方法或方法体中的变量，作用域是其所在的代码块，可以分为如下三种：

- 形参

```java
public class Main {
    // 方法中的参数
    public static void func(int num) {
        System.out.println("num = " + num);
    }

    public static void main(String[] args) {
        func(3);
    }
}
```

- 方法体内定义

```java
public class Main {
    public static void main(String[] args) {
        int num = 10;
        if (num > 5) {
            // 声明一个 int 类型的局部变量
            int tmp = 5;
            System.out.println("tmp = " + tmp);
            System.out.println("num = " + num);
        }
        System.out.println("num = " + num);
    }
}
```

- 代码块定义

```java
public class Main {
    public static void func() {
        try {
            System.out.println("Hello!Exception!");
        } catch (Exception e) { // 异常处理块，参数为 Exception 类型
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        func();
    }
}
```

### 7.常量

既然有变量，那就有与之相对的常量（也就是值是固定的，不能再变）。

常量又叫做字面常量，是通过数据直接来表示的，在程序运行过程中不能发生改变。通常我们把 Java 中用 `final` 关键字所修饰的成员变量叫做常量，它的值一旦给定就无法再进行改变。其语法如下：

```java
final 数据类型 常量名 = 常量初始值;
```

```java
public class Main{
    public static void main(String[] args){
        // 声明一个常量并赋值
        final int num = 1024;

        // 再次赋值，将导致编译错误
        num = 1943;

        // 声明一个常量但不赋值
        final int id;
        // 因为声明时未赋值，所以可以进程初次赋值
        id = 1;
        // 常量已经赋值过了，再次赋值将导致编译错误
        id = 2;
    }
}
```

常量可以分为如下3中类型：

- **静态常量**：`final` 之前用 `public static` 修饰，表示该常量的作用域是全局的，我们不用创建对象就能够访问它
- **成员常量**：类似于成员变量，但是最大的不同在于它不能被修改
- **局部常量**：作用类似局部变量，不同之处也在于不能修改

```java
public class Main{
    // 静态变量
    public static final dobule PI = 3.14;

    // 成员常量
    final int num = 1024;

    public static void main(String[] args){
        // 局部变量
        final long count = 1000;
    }
}
```

PS：`final` 修饰变量后，该变量则变为常量。而 `final` 也还可以用来修饰类和方法，修饰方法时，表示这个方法不能被重写（但可以重载）；修饰类时，则表示该类无法被继承。

## 常用进制转换

Java 中已经将常用的进制转换方法封装好了，我们只需要调用对用方法即可。

|        转换        |                 方法                  |      返回      |
| :----------------: | :-----------------------------------: | :------------: |
|  十进制 -> 二进制  |      `Integer.toBinary(int num)`      |  二进制字符串  |
|  十进制 -> 八进制  |   `Integer.toOctalString(int num)`    |  八进制字符串  |
| 十进制 -> 十六进制 |    `Integer.toHexString(int num)`     | 十六进制字符串 |
|  十进制 -> N进制   |  `Integer.toString(int num, int  N)`  |  N进制字符串   |
|  N进制 -> 十进制   | `Integer.parseInt(String str, int N)` |    十进制数    |

```java
public class Main {
    public static void main(String[] args) {
        int num = 200;
        System.out.println(num + " 的二进制是:" + Integer.toBinaryString(num));
        System.out.println(num + " 的八进制是:" + Integer.toOctalString(num));
        System.out.println(num + " 的十六进制是:" + Integer.toHexString(num));
        System.out.println(num + " 的三进制是:" + Integer.toString(num, 3));
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        String str = "21104";
        int N = 5;
        System.out.println(str + " 的十进制是:" + Integer.parseInt(str, N));
    }
}
```

## 操作符

###  1.算数运算符

常见的算数运算符主要有下表中的几种，主要是针对整型和浮点类型的运算

| 操作符 |               描述                |
| :----: | :-------------------------------: |
|  `+`   |     加法 - 相加运算符两侧的值     |
|  `-`   |    减法 - 左操作数减去右操作数    |
|  `*`   |     乘法 - 相乘操作符两侧的值     |
|  `/`   |    除法 - 左操作数除以右操作数    |
|  `%`   | 取余 - 左操作数除以右操作数的余数 |
|  `++`  |      自增 - 操作数的值增加1       |
|  `--`  |      自减 - 操作数的值减少1       |

**注意**：`++` 和 `--` 可以放在操作数之前，也可以放在操作数之后；**位于操作数之前时，先自增/自减，再赋值；位于操作数之后，先赋值，再自增/减**；总结起来就是**符号在前就先加/减，符号在后就后加/减**。

### 2.关系运算符

关系运算符主要是指两个数据间的关系，两者之间的比较结果用逻辑值表示，常用来比较判断两个变量或常量的大小。常见的关系运算符及含义如下表：

| 运算符 |                            描述                            |
| :----: | :--------------------------------------------------------: |
|  `==`  |       检查两个操作数的值是否相等，如果相等则条件为真       |
|  `!=`  |     检查两个操作数的值是否相等，如果值不相等则条件为真     |
|  `>`   |     检查左操作数的值是否大于右操作数，如果是则条件为真     |
|  `<`   |       检查左操作数是否小于右操作数，如果是则条件为真       |
|  `>=`  | 检查左操作数的值是否大于等于右操作数的值，如果是则条件为真 |
|  `<=`  | 检查左操作数的值是否小于等于右操作数的值，如果是则条件为真 |

### 3.位运算符

位运算符主要用来对操作数二进制的位进行运算，其运算结果是整型的。常见的位运算符及功能描述如下表所示：

| 操作符 |                             描述                             |
| :----: | :----------------------------------------------------------: |
|  `&`   |            如果相对应位都是1，则结果为1，否则为0             |
|  `|`   |            如果相对应位都是0，则结果为0，否则为1             |
|  `^`   |            如果相对应位值相同，则结果为0，否则为1            |
|  `~`   |      按位取反运算符翻转操作数的每一位，即0变为1，1变成0      |
|  `<<`  |      按位左移运算符。左操作数按位左移右操作数指定的位数      |
|  `>>`  |      按位右移运算符。左操作数按位右移右操作数指定的位数      |
| `>>>`  | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动的到的空位以零填充 |

## Java 循环结构

顺序结构的程序语句只能被执行一次。如果想要同样的操作执行多次，就需要使用循环结构。

### 1.while 循环

while 是最基本的循环，它的结构为：

```java
while( 布尔表达式 ) {
  //循环内容
}
```

只要布尔表达式为 true，循环就会一直执行下去。

### 2.do...while 循环

对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候需要即使不满足条件，也至少执行一次。

do...while 循环和 while 循环相似，不同的是，do...while 循环至少会执行一次。

```java
do {
       //代码语句
} while(布尔表达式);
```

**注意**：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。

### 3.for 循环

虽然所有循环结构都可以用 while 或者 do...while 表示，但 Java 提供了另一种语句——for 循环，使一些循环结构变得更加简单。

for 循环执行的次数是在执行前就确定的。语法格式如下：

```java
for(初始化; 布尔表达式; 更新) {
    //代码语句
}
```

关于 for 循环有以下几点说明：

- 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。
- 然后，检测布尔表达式的值，如果为 true，循环体被执行。如果为 false，循环终止，开始执行循环体后面的语句。
- 执行一次循环后，更新循环控制变量
- 再次检测布尔表达。循环执行上面的过程。

### 4.Java 增强 for 循环





## B站视频

### 1. P1 - 14

Java 是一门高级编程语言，是1995年由SUN公司研发，2009被Oracle公司收购。Java 之父是詹姆斯.高斯林

Java 的技术平台包括 Java SE标准版、Java EE企业版	Java ME小型版。 



**Java：**执行工具

**Javac：**编译工具

> Java 程序都是高级语言，计算机底层是硬件不能识别这些语言，必须先通过 Javac 编译工具进行翻译，然后再通过 Java 执行工具执行才可以驱动机器干活。
>



**命令行窗口的常用命令**

| 常用命令 | 作用                                                         |
| :------: | :----------------------------------------------------------- |
|  **D:**  | 切换到D盘下                                                  |
| **dir**  | 查看当前路径下的文件信息                                     |
|  **cd**  | 进入某个目录<br />回到上级目录：cd ..<br />回退到盘符根目录：cd \ |
| **cls**  | 清屏                                                         |



**Java 程序开发的三个步骤**：编写代码、编译代码、运行代码



**JDK 的组成**

JVM：Java virtual machine，Java 虚拟机，真正运行 Java 程序的地方

核心类库：Java 自己写好的程序，给程序员自己的的程序调用的

JRE：Java runtime environment，Java 的运行环境

开发工具：javac、java、...

 **Java 的跨平台、工作原理**

一次编译、处处可用



**Path环境变量**

Path环境变量用于记住程序路径，方便在命令行窗口的任意目录启动程序



**IDEA 管理 Java 程序的结构**

- project：项目、工程
- module：模块
- package：包
- class：类

**IDEA 快捷键**

| 快捷键                   | 功能效果                  |
| ------------------------ | ------------------------- |
| main/psvm、sout、...     | 快速键入相关代码          |
| ctrl+D                   | 复制当前行数据到下一行    |
| ctrl+Y                   | 删除所在行，建议用 ctrl+X |
| ctrl+alt+L               | 格式化代码                |
| alt+shift+↑，alt+shift+↓ | 上下移动当前代码          |
| ctrl+/，ctrl+shift+/     | 对代码进行注释            |

------

###  2. P15 - 30

**注释**：是写在程序中对代码进行解释说明的文字，方便自己和其他人查看，以便理解程序。

- 单行注释：`//`
- 多行注释：`/*  内容 */`
- 文档注释：`/**  内容  **/`

**字面量**：计算机是用来处理数据的，字面量就是告诉程序员：数据在程序中的书写格式。



**字符**

- 单引号 `' '` ：有且只能有一个字符
- 双引号 `" "`：里面的内容任意长度



**变量**

- 定义：用来存储一个数据的，本质是内存中的一块区域
- 作用：是用来记住程序要处理的数据的，编写代码更灵活，管理代码更方便
- 定义格式： `数据类型 变量名称 = 数据;`
- 特点：变量中装的数据是可以被替换的

 **使用变量的几个注意事项**

- 变量要先声明再使用
- 变量是什么类型，就应该用来装什么类型的数据，否则报错
- 变量是从定义开始到 "}" 截止的范围内有效；且同一个范围内，定的多个变量，它们的名称不能一样
- 变量定义的时候可以不赋初始值，但在使用时，变量里必须有值，否则报错



**关键字**

- Java 语言自己用到的一些词，有特殊作用的，我们称之为关键字，如：`public、class、int、double、...`

> 注意：关键字是 Java 用了的，我们就不能用来做：类名、变量名，否则会报错 

**标识符**

- 定义：标识符就是名字，我们写程序时会起一些名字，如类名、变量名等等都是标识符
- 基本组成：有数字、字母、下划线(_)和美元符($)等组成
- 强制要求：不能以数字开头、不能用关键字做为名字、区分大小写

**标识符的建议规范**

- 变量名称：满足标识符规则，同时建议用英文、有意义、首字母小写，满足“驼峰模式”，例如： `int studyNumber = 59;`

- 类名称：满足标识符规则，建议全英文、有意义、首字母大写，满足“驼峰模式”，例如：`HelloWorld, Student`




**变量里的数据在计算机中的存储原理**

- 二进制（除二取余法）
- 计算机中表示数据的最小单元：一个字节（byte，简称B，是使用8个二进制位组成的）
- 字节中的每个二进制位就成为 位（bit，简称b），1B = 8b

**字符、图片、声音的存储说明**

- 字符：ASCII编码表，即美国信息交换标准编码，规定了现代英语、数字字符和其他西欧字符对应的数字编号
- 图片： 由无数个像素点组成，每个像素点用 0 ~ 255 * 255 * 255 表示其颜色，存储其三个二进制
- 声音：波形坐标的二进制



**二进制、八进制、十六进制**

- 十进制转二进制：除二取余
- 二进制转十进制：以2为底的幂与位数相乘再相加
- 为了便于观察和表示二进制，推出了八进制和十六进制
- 每3位二进制作为一个单元，最小数是0（000），最大数是7（111），共8个数字，这就是八进制
- 每4位二进制作为一个单元，最小数是0（0000），最大数是15（F），共16个数字，依次用：`0~9 A B C D E F` 代表就是十六进制


> 注意：Java 程序中支持书写二进制、八进制、十六进制的数据，分别需要以0B或者0b、0、0X或者0x开头
>

**计算机的数据单位**

- 计算机表示数据的最小组成单元是：字节，1B = 8b
- 在B的基础上，计算机发展出了 KB、MB、GB、TB、...这些数据单位

> 1B = 8b
>
> 1KB = 1024B
>
> 1MB = 1024KB
>
> 1GB = 1024MB
>
> 1TB = 1024GB



**数据类型的分类**

**基本数据类型**：4大类8种

- 整型：`byte、short、int（默认）、long`
- 浮点型：`float、double（默认）`
- 字符型：`char`
- 布尔型：`boolean`

> 注意：在 Java 代码编写中，随便写一个整型字面量默认是 int 类型的，如果希望随便写一个整型字面量默认是 long 类型的，需要在后面写 `L/l`
>
> 随便写的小数字面量，默认是 double ，如果希望小数是 float ，后面加上 F/f

**引用数据类型**：`String` 称之为字符串类型，定义的变量可以用于记住一个字符串数据



**类型转换**

- 自动类型转换：类型范围小的变量，可以直接赋值给类型范围大的变量 【`byte -> short / char -> int -> long -> float -> double`】
- 表达式的自动类型转换：在表达式中，小范围类型的变量，会自动转换成表达式中较大范围的类型，再参与运算

> 注意：表达式的最终结果类型由表达式中的最高类型决定
>
> ​			==在表达式中，byte、short、char 是直接转换成 int 类型参与运算的==

- 强制类型转换：强制将类型范围大的变量、数据赋值给类型范围小的变量 `数据类型 变量2 = (数据类型) 变量1、数据`

> 注意：强制类型转换可能出现数据丢失
>
> ​			小数强制转换成整数时直接截断小数保留整数



**算数运算符**

| 操作符 |                             描述                             |
| :----: | :----------------------------------------------------------: |
|  `+`   |                  加法 - 相加运算符两侧的值                   |
|  `-`   |                 减法 - 左操作数减去右操作数                  |
|  `*`   |                  乘法 - 相乘操作符两侧的值                   |
|  `/`   | 除法 - 左操作数除以右操作数 ==在Java中两个整数相除结果还是整数== |
|  `%`   |              取余 - 左操作数除以右操作数的余数               |
|  `++`  |                    自增 - 操作数的值增加1                    |
|  `--`  |                    自减 - 操作数的值减少1                    |

`+` 符号与字符串运算的时候是用作连接符的，其结果依然是一个字符串 

`++、--` 只能操作变量，不能操作字面量

​			  如果不是单独使用（如在表达式中，或者同时有其它操作），放在变量前后会存在明显区别。放在变量的前面，先对变量进行 +1、-1，再拿变量的值进行运算；放在变量的后面，先拿变量的值进行运算，再对变量的值进行 +1、-1

------

### 3. P31 - 40

**赋值运算符（扩展）**

| 符号 | 用法   | 作用       | 底层代码形式         |
| ---- | ------ | ---------- | -------------------- |
| +=   | a += b | 加后赋值   | a = (a的类型)(a + b) |
| -=   | a -= b | 减后赋值   | a = (a的类型)(a - b) |
| *=   | a *= b | 乘后赋值   | a = (a的类型)(a * b) |
| /=   | a /= b | 除后赋值   | a = (a的类型)(a / b) |
| %=   | a %= b | 取余后赋值 | a = (a的类型)(a % b) |

**关系运算符**

判断数据是否满足条件，最终会返回一个判断的结果，这个结果是布尔类型的值：true/fasle

| 符号 | 例子   | 作用                   | 结果                          |
| ---- | ------ | ---------------------- | ----------------------------- |
| >    | a > b  | 判断a是否大于b         | 成立返回true、不成立返回false |
| >=   | a >= b | 判断a是否大于或者等于b | 成立返回true、不成立返回false |
| <    | a < b  | 判断a是否小于b         | 成立返回true、不成立返回false |
| <=   | a <= b | 判断a是否小于或者等于b | 成立返回true、不成立返回false |
| ==   | a == b | 判断a是否等于b         | 成立返回true、不成立返回false |
| !=   | a != b | 判断a是否不等于b       | 成立返回true、不成立返回false |

**逻辑运算符**

把多个条件放在一起运算，最终返回布尔类型的值：true/false

| 符号 | 叫法         | 例子             | 运算逻辑                                                     |
| ---- | ------------ | ---------------- | ------------------------------------------------------------ |
| &    | 逻辑与       | 2 > 1 & 3 > 2    | 多个条件必须都为true，结果才是true；有一个是false，结果就是false |
| \|   | 逻辑或       | 2 > 1 \| 3 < 5   | 多个条件中只要有一个是true，结果就是true                     |
| !    | 逻辑非       | ! (2 > 1)        | 就是取反：你真我假，你假我真。! true == fasle、! false == true |
| ^    | 逻辑异或     | 2 > 1 ^ 3 > 1    | 前后条件的结果相同，就直接返回false，前后条件的结果不同，才返回true |
| &&   | 短路与  双与 | 2 > 10 && 3 > 2  | 判断结果与 & 一样，过程不同：左边为false，右边则不执行       |
| \|\| | 短路或  双或 | 2 > 1 \|\| 3 < 5 | 判断结果与 \| 一样，过程不同：左边为true，右边则不执行       |

> 注意：实际开发中，常用的逻辑运算符还是 && 、||、!

**三元运算符**

- 格式：`条件表达式 ? 值1 : 值2;`
- 执行流程：首先计算关系表达式的值，如果值为true，返回值1；如果为false，返回值2

**运算符优先级**

- 在表达式中，哪个运算符先执行后执行是要看优先级的



**API(Application Programming Interfacr: 应用程序编程接口)**

- Java 写好的程序，程序员可以直接拿来调用
- Java 为自己写好的程序提供了相应的程序使用说明书(API文档)

**使用 Scanner 接收用户键盘输入的数据，需要三个步骤**

- 导包：告诉程序去 JDK 的哪个包中找扫描器技术 （IDEA工具会帮助我们导包）
- 抄代码：代表得到键盘扫描器对象（东西）
- 抄代码：等到接收用户输入数据

> 注意：System、String在 JDK 中的 Java.lang 包下；lang包不需要我们导包，是默认的包



**程序中最经典的三种执行顺序**

**1.顺序结构**：自上而下的执行代码

**2.分支结构**：根据条件，选择对应代码执行

- if 分支：根据条件（真或假）来决定执行某段代码

> () 后不能跟";" 否则 {} 中的代码将不受 if 的控制
>
> 如果 if 语句的 {} 中只有一行代码的情况， {} 可以省略不写，但是不推荐

```java
// 1
if (条件表达式) {
	代码;
}
// 2
if (条件表达式) {
	代码1;
}else {
	代码2;
}
// 3
if (条件表达式) {
	代码1;
}else if (条件表达式2) {
	code2;
}else {
	code3;
}

```

- switch 分支：是通过比较值来决定执行哪条分支

```java
switch (表达式) {
	case value1:
		code;
		break;
	case value2:
		code2:
		break;
	default:
		code3;
}
```

> - if 在功能上远远强大于 switch
> - 当前条件是区间的时候，应该使用 if 分支结构
> - 当条件是与一个一个的值比较的时候，switch 分支更合适：格式良好，性能较好，代码优雅

> **使用 switch 分支的几点注意事项：**
>
> 1. 表达式类型只能是 byte、short、int、char，JDK5开始支持枚举，JDK7开始支持 String、==不支持 double、float、long==
>
> 2. case 给出的值不允许重复，且只能是字面量，不能是变量
> 3. 正常使用 switch 的时候，不要忘记写 break，否则会出现穿透现象

**switch 穿透性在这些情况下可以简化代码**：当存在多个 case 分支的代码相同时，可以把相同的代码放到一个 case 块中，其他的 case 块都通过穿透性穿透到该 case 块执行代码即可，这样可以简化代码

**3.循环结构**：控制某段代码重复执行

- for 循环

```Java
// 循环格式
for (初始化语句; 循环条件; 迭代语句) {
	循环体;
}
```

- while 循环

```java
// 循环格式
初始化语句;
while (循环条件) {
	循环体;
	迭代语句;
}
```

> **while、for 循环的区别**
>
> 功能上完全一样的，for 能解决的 while 也能解决，反之亦然
>
> 使用规范：知道循环几次，使用 for 循环； 不知道循环几次建议使用 while 

- do-while 循环：先执行、后判断

```java
// 格式定义
初始化语句;
do {
	循环体;
	迭代语句;
} while (循环条件);
```

**三种循环的区别小结**

- for 循环和 while 循环（先判断后执行）；do...while（先执行后判断）
- for 循环和 while 循环的执行流程是一模一样的，功能上无区别，for 能做的 while 也能做，反之亦然
- 使用规范：如果已知循环次数建议使用 for 循环；如果不清楚要循环多少次建议使用 while 循环
- 其他区别：for 循环中，控制循环的变量只能在循环中使用。while 循环中，控制循环的变量在循环后还可以继续使用

------

### 4. P41 - 53

【第4次打卡，包括 do...while 循环的内容】

**死循环**：可以一直执行下去的一种循环，如果没有干预不会停下来。应用场景：服务器程序

```java
// 死循环的写法
for (; ; ) {
	System.out.println("Hello World1");
}
// 经典写法
while (true) {
	System.out.println("Hello World2");
}

do {
	System.out.println("Hello World3");
} while (true);
```



**循环嵌套**：循环中又包含循环



**跳转关键字**

- break：跳出并结束当前所在循环的执行
- continue：用于跳出当前循环的当次执行，直接进入循环的下一次执行

> 注意：break 只能用于结束所在循环，或者结束所在 switch 分支的执行
>
> ​			continue 只能在循环中进行使用

 

**数组**

定义：数组就是一个容器，用来存储一批同种类型的数据。

**静态初始化数组**：定义数组的时候直接给数组赋值

```java
// 完整格式
数据类型[] 数组名 = new 数据类型[]{元素1, 元素2, 元素3, ...};

// 简化格式
数据类型[] 数组名 = {元素1, 元素2, 元素3, ...};
```

> 注意： `数据类型[] 数组名` 也可以写成 `数据类型 数组名[]`
>
> ​			 什么类型的数组只能存放什么类型的数据	
>
> ​			 **数组变量名中存储的是数组在内存中的地址，数组是一种引用数据类型**

数组的访问：数组名[索引]

数组的长度属性：length  `arr.length`

数组的遍历：一个一个数据的访问数组中的数据（循环） 

**动态初始化数组**：定义数组时先不存入具体的元素值，只确定数组存储的数据类型和数组的长度

```java
// 动态初始化格式
数组类型[] 数组名 = new 数组类型[长度];
```

> 动态初始化：适合开始不确定具体元素值，只知道元素个数的业务场景
>
> 静态初始化：适合一开始就知道要存入哪些元素值得业务场景



**数组的执行原理，Java 程序的执行原理**

**Java 内存分配介绍**

- 方法区：字节码文件先加载到这里 .class 文件
- 栈：方法运行时所进入的内存变量也是在这里
- 堆：new 出来的东西会在这块内存中开辟空间并产生地址
- 本地方法栈
- 寄存器

> 注意：如果某个数组变量存储的地址是 null，那么该变量将不再指向任何数组对象

**多个数组变量指向同一个数组对象**

- 多个数组变量中存储的同一个数组对象的地址
- 多个变量修改的都是同一个数组对象中的数据



**Debug工具**

- 定义：IDEA 自带的断点调试工具，可以控制代码从断点开始一行一行的执行，然后详细观看程序执行的情况
- 基本使用步骤：① 在需要控制的代码行左侧，点击一下，形成断点
- ​						   ② 选择使用 Debug 方式启动程序，启动后程序会在断点暂停
- ​						   ③ 控制代码一行一行的往下执行

------

### 5. P54 - 64

**方法**

- 定义：是一种语法结构，它可以把一段代码封装成一个功能，以便重复调用。

```Java
// 完整格式
修饰符 返回值类型 方法名(形参列表) {
	方法体代码(需要执行的功能代码);
	return 返回值;
}
```

> 注意：方法的修饰符，暂时都使用 public static 修饰
>
> ​			方法申明了具体的返回值类型，内部必须使用 return 返回对应类型的数据
>
> ​			形参列表可以有多个，甚至可以没有；如果有多个形参，形参之间必须用 , 隔开，且不能给初始值

- 优点：提高了代码的复用性 ，提高了开发效率

​		 	      让程序的逻辑更清晰

**方法的其他形式**

方法定义时：需要按照方法解决的实际业务需求，来设计合理的方法形式解决问题

> 注意：如果方法不需要返回数据，返回值类型必须申明成 void（无返回值申明），此时方法内部不可以使用 return 返回数据
>
> ​		    方法如果不需要接收数据，则不需要定义形参，且调用方法是也不可以传数据给方法了
>
> ​		    没有参数，且没有返回值类型 void 申明的方法，称为无参数、无返回值的方法，依次类推

**方法定义的其他形式及常见问题**

- 方法在类中的位置放前放后无所谓，但一个方法不能定义在另一个方法里面
- 方法的返回值类型写 void（无返回申明）时，方法内不能是用 return 返回数据，如果方法的返回值类型写了具体类型，方法内部则必须使用 return 返回对应类型的数据

- return 语句的下面，不能编写代码，属于无效的代码，执行不到这儿
- 方法不调用就不会执行，调用方法时，传给方法的数据，必须严格匹配方法的参数情况
- 调用有返回值的方法，有3种方式：1.可以定义变量接收结果  2.或者直接输出调用  3.甚至直接调用
- 调用无返回值的方法，只有1种方式：只能直接调用



**方法的案例**

设计方法的技巧：1.方法是否需要接收数据进行处理（定义形参）

​							   2.方法是否需要返回数据（定义返回值类型，并 return）

​							   3.方法要处理的业务（编程能力）



**方法在计算机中的执行原理**

- 方法被调用的时候，是进入到==栈内存==中运行 （栈：先进后出）
- 使用栈内存，可以保证一个方法调用完另一个方法后，可以回来



**Java 的参数传递机制（面试题）：值传递**

所谓值传递，指的是在传输实参给方法的形参的时候，传输的是实参变量中存储的值的==副本==

实参：在方法内部定义的变量 



**方法重载**

- 定义：==一个类中==，出现==多个方法的名称相同==，但是它们的==形参列表是不同的==，那么这些方法就称为==方法重载==了。

> 注意：
>
> ​	一个类中，只要一些方法的名称相同、形参列表不同，那么它们就是方法重载了，其它的都不管（如：修饰符，返回值类型是否一样都无所谓）
>
> ​	形参列表不同指的是：形参的个数、类型、顺序不同，不关心形参的名称

- 应用场景：开发中我们经常需要为处理一类业务，提供多种解决方案，此时用方法重载来设计是很专业的

**在方法中单独使用 return 关键字**

`return;` 可以用在无返回值的方法中，作用是：立即跳出并==结束当前方法的执行==

 补充：`break;` 跳出并结束当前所在循环的执行

​			 `continue;` 结束当前所在循环的档次执行，进入下一次执行



✅**案例一和二：买飞机票、验证码**

- 使用 if 分支结构实现通过判断数据在哪个区间，来决定执行哪个业务
- 通过 switch 分支结构实现通过判断数据匹配哪个值，来决定执行哪个业务

✅**案例三：评委打分**

步骤：①定义一个动态初始化的数组，用于录入评委打分  `Scanner sc = new Scanner(System.in);`

​	    	②提前定义三个变量用来记住数组中的最大值、最小值、总和

​			③遍历数组中的每个数据，依次找出最大值、最小值、总和

​			④遍历结束后，按照计算规则算出选手的最终得分，并返回即可

✅**案例四：数字加密**

- 反转数组，就是对数组中的元素，按照前后位置，依次交换数据
- 如果一个方法里要做的事情比较多，在开发中一般会把多个是拆成多个方法去完成，也就是独立功能独立成一个方法

✅**案例五：数组拷贝**

------

### 6. P65 - 75

✅**案例六：抢红包**

随机打乱数组顺序，模拟随机抽奖

✅**案例七：找素数**

素数：除了1和它本身以外，不能被其他正整数整除，就叫素数

`OUT:` 为外部循环指定标签； `continue OUT;` 结束外部循环的档次执行

✅**案例八：打印乘法表、打印三角形**

计算机只能按行打印

✅**案例九：模拟双色球**

每次用户投注一个红球号码后，都去调用一个方法来判断这个号码是否已经选择过，如果选择过，让用户重新选号

每次随机一个 1-33 之间的红球号码后，都去调用一个方法来判断这个号码是否已经出现过，如果出现过，让系统重新选号



**oop：面向对象**

- 面向对象编程，oop，开发一个一个的对象，把数据交给对象，再调用对象的方法来完成对数据的处理
- 优点：符合人类的思维习惯，编程更简单、更直观
- 对象本质上是一种特殊的数据结构
- class也就是类，也成为对象的设计图（或者对象的模板）
- 祖师爷认为万物皆对象，谁的数据谁处理

**对象在计算机中的执行原理**

- 使用 new 关键字，在堆内存中开辟一块内存区域代表一个学生对象
- 变量里面记住的是学生对象的地址

> 如果一个变量中存储的是对象的地址，那么这个变量就是引用类型的变量

**类和对象的一些注意事项**

- 类名建议用英文单词，首字母大写，满足驼峰模式，且要有意义
- 类中定义的变量也称为成员变量（对象的属性），类中定义的方法也称为成员方法（对象的行为）
- 成员变量本身存在默认值，在定义成员变量时一般来说不需要赋初始值（没有意义）
- 一个代码文件中，可以写多个class类，但只能一个用 public 修饰，且 public 修饰的类名必须称为代码文件名
- 对象与对象之间的数据不会相互影响，但多个变量指向同一个对象时就会相互影响了
- 如果某个对象没有一个变量引用它，则该对象无法被操作，该对象会成为所谓的垃圾对象

>  注意：当堆内存中的对象，没有被任何变量引用（指向）时，就会被判定为内存中的“垃圾”
>
> ​			 Java 存在自动垃圾回收机制，会自动清除掉垃圾对象，程序员不用操行



**this 关键字**

定义：this 就是一个变量，可以用在方法中，来拿到当前对象；哪个对象调用方法，this 就指向哪个对象，也就是拿到哪个对象

应该场景：用来解决对象的成员变量与方法内部变量的名称一样时，导致访问冲突的问题



**构造器**

```Java
// 格式
public class Student {
	// 构造器
	public Student(){
		....
	}
}
```

- 特点：创建对象时，对象会去调用构造器
- 应用场景：创建对象时，同时完成对对象成员变量（属性）的初始化赋值
- 注意事项：①类在设计时，如果不写构造器，Java 是会为类自动生成一个无参构造器的；②一旦定义了有参数构造器，Java 就不会帮我们的类自动生成无参构造器了，此时就建议自己手写一个无参构造器出来

 

**封装**

> **面向对象的三大特征：封装、继承、多态**

- 定义：用类设计对象处理某一个事物的数据时，应该把要处理的数据，以及处理这些数据的方法，设计到一个对象中去
- 设计规范：合理隐藏、合理暴露（将成员变量隐藏起来 private，再设计get、set方法实现外界访问） 

**实体 JavaBean**

定义：一种特殊形式的类。

特点：该类的成员变量都要私有，并且要对外提供相应的 getXxx，setXxx方法；类中必须要有一个公共的无参构造器

应用场景：实体类对应的是软件开发里现在比较流行的开发方法，数据和数据的业务处理相分离



**成员变量与局部变量的区别**

- 类中位置不同：成员变量（类中，方法外）、局部变量（常见于方法中）
- 初始化值不同：成员变量（有默认值，不需要初始化赋值）、局部变量（没有默认值，使用之前必须完成赋值）
- 内存位置不同：成员变量（存在于堆内存）、局部变量（栈内存）
- 作用域不同：成员变量（整个对象）、局部变量（在所归属的大括号中）
- 生命周期不同：成员变量（与对象同生共死）、局部变量（方法调用而生，方法结束而亡）

------

### 7. P76 - 86

**API**

API(Application Programming Interface：应用程序编程接口)

**包**

定义：是用来分门别类的管理各种不同程序的，类似于文件夹，建包有利于程序的管理和维护

**在自己的程序中调用其他包下的程序的注意事项**

- 如果当前程序中，要调用自己所在包下的其他程序，可以直接调用（同一个包下的类，互相可以直接调用）
- 如果当前程序中，要调用其他包下的程序，则必须在当前程序中导包，才可以访问！（格式：`import 包名.类名`）
- 如果当前程序中，要调用 Java 提供的程序，也需要先导包才可以使用；但是 java.lang 包下的程序是不需要我们导包的，可以直接使用
- 如果当前程序中，要调用多个不同包下的程序，而这些程序名正好一样，此时默认只能导入一个程序，另一个程序必须带包名访问



**String**

定义：String 代表字符串，可以用来创建对象封装字符串数据，并对其进行处理

创建对象封装字符串数据的方式

- 方式一：Java 程序中的所有字符串文字（例如“abc”）都为此类的对象
- 方式二：调用 String 类的构造器初始化字符串对象

**String 的常用方法**

- `public int length()`：获取字符串的长度返回(就是字符个数)
- `public char charAt(int index)`：获取某个索引位置处的字符返回
- `public char[] toCharArray()`：将当前字符串转换成字符数组返回
- `public boolean equals(Object anObject)`：判断当前字符串与另一个字符串的内容一样，一样返回true
- `public boolean equalsIgnoreCase(String anotherString)`：判断当前字符串与另一个字符串的内容是否一样(忽略大小写)
- `public String substring(int beginIndex，int endIndex)`：根据开始和结束索引进行截取，得到新的字符串(包前不包后)
- `public String substring(int beginIndex)`：从传入的索引处截取，截取到末尾，得到新的字符串返回
- `public String replace(CharSequence target， CharSequence replacement)`：使用新值，将字符串中的旧值替换，得到新的字符串
- `public boolean contains(CharSequence s)`：判断字符串中是否包含了某个字符串
- `public boolean startswith(String prefix)`：判断字符串是否以某个字符串内容开头，开头返回true，反之flase（判断姓氏）
- `public String[] split(String regex)`：把字符串按照某个字符串内容分割，并返回字符串数组回来

**String 使用时的注意事项**

- String 对象的内容是不可改变，被称为不可变字符串对象
- 只要是以 "..." 方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份；但通过 new 方式创建字符串对象，每 new 一次都会产生一个新的对象放在堆内存中



**ArrayList<E>**

定义：代表一种集合，集合是一种容器，用来装数据的，类似于数组（ArrayList 是用的最多、最常见的一种集合）

集合的特点：大小长度可变，开发中用的更多

**构造器**：public ArrayList()：创建一个空的集合对象

**常用的方法**

- `public boolean add(E e)`：将指定的元素添加到此集合的末尾
- `public void add(int index,E element)`：在此集合中的指定位置插入指定的元素
- `public E get(int index)`：返回指定索引处的元素
- `public int size()`：返回集合中的元素的个数
- `public E remove(int index)`：删除指定索引处的元素，返回被删除的元素
- `public boolean remove(Object o)`：删除指定的元素，返回删除是否成功
- `public E set(int index,E element)`：修改指定索引处的元素，返回被修改的元素



**ATM系统**

alt + enter：创建方法

return：跳出并结束当前方法

------

### 8. P87 - 98

**static**

定义：静态，可以修饰成员变量、成员方法

**成员变量按照有无 static 修饰，分为两种**：

- 类变量：有 static 修饰，属于类，在计算机里只有一份，会被类和类的所有对象共享  `类名.类变量`。应用场景：在开发中，如果某个数据只需要一份，且希望能够被共享（访问、修改），则该数据可以定义成类变量来记住
- 实例变量：无 static 修饰，属于每个对象 `对象.实例变量`



**static 修饰成员方法**

- 类方法：有 static 修饰的成员方法，属于类，可以直接用类名访问，也可以用对象访问  `类名.类方法`  
- 类方法应用场景：工具类；工具类中的方法都是一些类方法，每个方法都是用来完成一个功能的，工具类是给开发人员共同使用的，提高了代码的复用性；方便，提高开发效率

> 多学一招：工具类没有创建对象的需求，建议将工具类的构造器进行私有 private

- 实例方法：无 static 修饰的成员方法，属于对象  `对象.实例方法`  



**static 的注意事项**

- 类方法中可以直接访问类的成员，不可以直接访问实例成员
- 实例方法中既可以直接访问类成员，也可以直接访问实例成员
- 实例方法中可以出现 this 关键字，类方法中不可以出现 this 关键字



**代码块**

1.代码块是类的5大成分之一（成员变量、构造器、方法、代码块、内部类）

2.代码块分为两种：

静态代码块：`static {}` ；

- 特点：类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次
- 作用：完成类的初始化，例如：对类变量的初始赋值

实例代码块：`{}`

- 特点：每次创建对象时，执行实例代码块，并在构造器前执行
- 作用：和构造器一样， 都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值



**设计模式**

定义：一个问题通常有 n 中解法，其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式

设计模式共有20多种，对用20多种软件开发过程中会遇到的问题

**单例设计模式**

作用：确保一个类只有一个对象

写法：把类的构造器私有			（==饿汉式单例== 使用频繁）

​			定义一个类变量记住类的一个对象

​			定义一个类方法，返回对象

应用场景：任务管理器、获取运行时对象

优点：在这些业务场景下，使用单例模式，可以避免浪费内存

==懒汉式单例设计模式==：拿对象时，才开始创建

写法：把类的构造器私有

​			定义一个类变量用于存储对象

​			提供一个类方法，保证返回的是同一个变量

------

### 9. P99 - 109

**继承**

定义：Java 中提供了一个关键字 extends，用这个关键字，可以让一个类和另一个类建立起父子关系

特点：子类能继承父类的非私有成员（成员变量、成员方法）

​			子类的对象是由子类、父类共同完成的

好处：减少重复代码的编写

**继承相关的注意事项**

1️⃣权限修饰符

定义：就是用来限制类中的成员（成员变量、成员方法、构造器、代码块...）能够被访问的范围

|  修饰符   | 在本类中 | 同一个包下的其他类离 | 任意包下的子类 | 任意包下的任意类里 |
| :-------: | :------: | :------------------: | :------------: | :----------------: |
|  private  |    √     |                      |                |                    |
|   缺省    |    √     |          √           |                |                    |
| protected |    √     |          √           |       √        |                    |
|  public   |    √     |          √           |       √        |         √          |

2️⃣单继承、Object类

Java 是单继承的，Java 中 的类不支持多继承，但是支持多层继承

Object 类是 Java 多有类的祖宗类。我们写的任何一个类，其实都是 object 的子类或子孙类

3️⃣方法重写

定义：当子类觉得父类中的某个方法不好用，或者无法满足自己的需求时，子类可以重写一个方法名称、参数列表一样的方法，去覆盖父类的这个方法，这就是方法重写

> 注意：重写后，方法的访问，Java 会遵循就近原则

方法重写的其它注意事项

- 使用 @Override 注解，可以指定Java编译器，检查我们方法重写的格式是否正确，代码的可读性也会更好
- 子类重写父类方法时，访问权限必须大于或者等于父类该方法的权限
- 重写的方法返回值类型，必须与被重写方法的返回值类型一样，或者范围更小
- 私有方法、静态方法不能被重写，如果重写会报错

 方法重写在开发中常见的应用场景

子类重写Object类的toString()方法，以便返回对象的内容

4️⃣子类中访问其他成员的特点

- 在子类中访问其他成员（成员变量、成员方法），是依照==就近原则==的
- 可以通过 super 关键字，指定访问父类的成员：super.父类成员变量/父类成员方法

5️⃣子类构造器的特点

- 子类的全部构造器，都会先调用父类的构造器，再执行自己
- 默认情况下，子类全部构造器的第一行代码都是 super() ，它会调用父类的无参数构造器
- 如果父类没有无参数构造器，则我们必须在子类构造器的第一行手写 super(...)，指定去调用父类的有参数构造器
- 在任意类的构造器中，是可以通过 this(...) 去调用该类的其他构造器的




**多态**

定义：是在继承/实现情况下的一种现象，表现为：对象多态、行为多态

前提：有==继承/实现==关系；存在父类引用子类对象；==存在方法重写==

注意：多态是对象、行为的多条，Java中的属性（成员变量）不谈多态

好处：在多态形式下，右边对象是==解耦合==的，更便于扩展和维护

​			定义方法时，使用父类类型的形参，可以接收一切子类对象，扩展性更强、更便利

问题：

​		多态下不能使用子类的独有功能：==强制类型转换==，编译阶段有继承或者实现关系就可以强制转换，但是运行时可能出现类型转换异常。强转前使用 instanceof 关键字，判断当前对象的真实类型，再进行强转 `对象 instanceof 类型`



**final关键字**：可以修饰（类、方法、变量）

修饰类：该类被称为最终类，特点是不能被继承了

修饰方法：该方法被称为最终方法，特点是不能被重写了

修饰变量：该变量只能被赋值一次

> 注意事项：final修饰基本类型的变量，变量存储的==数据==不能被改变
>
> ​					final修饰引用类型的变量，变量存储的==地址==不能被改变，但地址所指向对象的内容是可以被改变的



**常量**

使用了static final修饰的成员变量就被称为常量

作用：通常用于记录系统的配置信息

优势：代码可读性更好，可维护性也更好

​			程序编译后，常量会被”宏替换“：出现常量的地方全部会替换成其记住的字面量，这样可以保证使用常量和直接用字面量的性能是一样的



**抽象类**

在Java中有一个关键字：abstract，意思是抽象的，可以用它修饰类、成员方法。修饰类，该类就是抽象类；修饰方法，该方法就是抽象方法。抽象方法不能有方法体

**抽象类注意事项、特点**

- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
- 类该有的成员（成员变量、方法、构造器）抽象类都可以有
- 抽象类最主要的特点：抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现
- 一个类继承抽象类，必须重写抽象类的全部抽象方法，否则这个类也必须定义为抽象类

 **抽象类的场景和好处**

父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现。我们设计这样的抽象类，就是为了更好的支持多态

**模板方法设计模式解决的问题**：解决方法中存在重复代码的问题

**模板方法设计模式的写法**

​		1️⃣定义一个抽象类

​		2️⃣在里面定义2个方法

- ​				一个是模板方法：把相同的代码放里面去
- ​				一个是抽象方法：具体实现交给子类完成

> 多学一招：建议使用final关键字修饰模板方法。模板方法是给对象直接使用的，不能被子类重写；一旦子类重写了模板方法，模板方法就是失效了



**接口**

Java提供了一个关键字interface，用这个关键字可以定义出一个特殊的结构：接口。

```Java
// 格式
public interface 接口名 {
	// 成员变量 （常量）
	// 成员方法（抽象方法）
}
```

>  注意：接口不能创建对象；接口是用来被类实现（implements）的，实现接口的类称为实现类

一个类可以实现多个接口（接口可以理解成干爹），实现类实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义成抽象类

**接口的好处**

- 弥补了类单继承的不足，一个类同时可以实习多个接口
- 让程序可以面向接口编程，这样程序员就可以灵活方便的切换各种业务实现

------

### 10. P110 - 120

**JDK8开始，接口中新增的三种方法**

- 默认方法：必须使用default修饰，默认会被public修饰。也就是实例方法：对象方法，必须使用实现类的对象来访问
- 私有方法：必须使用private修饰。JDK9开始才支持的。也就是实例方法。
- 静态方法：必须使用static修饰，默认会被public修饰。

> 增强了接口的能力，更便于项目的扩展和维护

**接口的多继承、使用接口的注意事项**

一个接口可以同时继承多个接口 

> 作用：便于实现类去实现

注意事项：

​		一个接口继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承

​		一个类实现多个接口，如果多个接口中存在方法名冲突，则此时不支持多实现

​		一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会优先用父类的

​		一个类实现了多个接口，多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可



**内部类**

是类中的五大成分之一（成员变量、方法、构造器、内部类、代码块），如果一个类定义在另一个类的内部，这个类就是内部类

场景：当一个类的内部，包含了一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类
1️⃣成员内部类：类中的一个普通成员

```java 
// 格式
外部类名.内部类名 对象名 = new 外部类(...).new 内部类(...);
```

>  注意：JDK16之前，成员内部类中不能定义静态成员，JDK16开始也可以定义静态成员了

2️⃣静态内部类：有static修饰的内部类，属于外部类自己持有

```Java
// 格式
外部类名.内部类名 对象名 = new 外部类.内部类(...);
```

3️⃣局部内部类：定义在方法中、代码块中、构造器等执行体中（鸡肋语法，看看就好）

4️⃣⭐**匿名内部类**：一种特殊的局部内部类；所谓匿名指的是程序员不需要为这个类声明名字

```Java
new 类或接口(参数值...) {
	类体(一般是方法重写)
}
```

特点：匿名内部类本质上就是一个子类，并会立即创建出一个子类对象

作用：用于更方便的创建一个子类对象

使用场景：通常作为一个参数传输的方法



**枚举**

是一种特殊的类

```java 
// 格式
修饰符 enum 枚举类名 {
	名称1, 名称2, ...;
	其他成员...
}
```

特点：枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量记住的都是枚举类的一个对象

​			枚举类的构造器都是私有的（写不写都只能是私有的），因此，枚举类对外不能创建对象

​			枚举类都是最终类，不可以被继承

​			枚举类中，从第二行开始，可以定义类的其他各种成员

​			编译器为枚举类新增了几个方法，并且枚举类都是继承：java.lang.Enum类的，从enum类也会继承到一些方法

场景：用来表示一组信息，然后作为参数进行传输（信息标志和分类）



**泛型**

定义：定义类、接口、方法时，同时声明了一个或者多个类型变量（如：<E>），称为泛型类、泛型接口、泛型方法，它们统称为泛型

作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力！这样可以避免强制类型转换，及其可能出现的异常

==本质：把具体的数据类型作为参数传给类型变量==

**泛型类**

```java
// 格式
修饰符 class 类名<类型变量, 类型变量, ...> {
	
}
```

**泛型接口**

```Java
// 格式
修饰符 interface 接口名<类型变量, 类型变量, ...> {
	
}
```

**泛型方法**

```java 
修饰符 <类型变量, 类型变量, ...> 返回值类型 方法名(形参列表) {

}
```

**泛型的注意事项**

泛型工作在编译阶段，一旦程序编译成class文件，class文件中就不存在泛型，这就是==泛型擦除==

泛型不支持基本数据类型，只能支持对象类型（引用数据类型）



**常用API**

1️⃣**Object类**的作用：Object类是Java中所有类的祖宗类，因此，Java中所有类的对象都可以直接使用Object类中提供的一些方法

Object类的常见方法

| 方法名                          | 说明                               |
| ------------------------------- | ---------------------------------- |
| public String toString()        | 返回对象的字符串表示形式           |
| public boolean equals(Object o) | 指示某个其他对象是否“等于”这个对象 |
| protected Object clone()        | 创建并返回此对象的副本             |

> clone分为浅克隆（拷贝地址）和深克隆（基本数据类型的数据直接拷贝，字符串数据拷贝的还是地址，其他对象则会创建新对象）

2️⃣**Objects**：工具类，提供了很多操作对象的静态方法给我们使用

常见方法

| 方法名                                           | 说明                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| public static boolean equals(Object a, Object b) | ==先做非空判断==，如果参数彼此相等则返回 `true`，否则返回 `false` |
| public static boolean isNull(Object obj)         | 如果提供的引用是 `null`，则返回 `true`，否则返回 `false`     |
| public static boolean nonNull(Obect obj)         | 如果提供的引用是非 `null` 则返回 `true` 否则返回 `false`     |

3️⃣**包装类**就是把基本类型的数据包装成对象

| 基本数据类型 | 对应的包装类（引用数据类型） |
| ------------ | ---------------------------- |
| byte         | Byte                         |
| short        | Short                        |
| int          | Integer                      |
| long         | Long                         |
| char         | Character                    |
| float        | Float                        |
| double       | Double                       |
| boolean      | Boolean                      |

| 方法                                 | 说明                                   |
| ------------------------------------ | -------------------------------------- |
| public static Integer valueOf(int i) | 返回代表指定 `int` 值的 `Integer` 实例 |

自动装箱：基本数据类型可以自动转换为包装类型

自动拆箱：包装类型可以自动转换为基本数据类型

4️⃣**StringBulider**

代表可变字符串对象，相当于是一个容器，它里面装的字符串是可以改变的，就是用来操作字符串的

好处：StringBuilder比String更适合做字符串的修改操作，效率会更高，代码也会更简洁

| 构造器                           | 说明                                                 |
| -------------------------------- | ---------------------------------------------------- |
| public StringBuilder()           | 构造一个没有字符且初始容量为 16 个字符的字符串生成器 |
| public StringBuilder(String str) | 构造一个初始化为指定字符串内容的字符串生成器         |

| 方法名称                              | 说明                                                |
| ------------------------------------- | --------------------------------------------------- |
| public StringBuilder append(任意类型) | 添加数据并返回StringBuilder对象本身                 |
| public StringBuilder reverse()        | 将对象的内容反转                                    |
| public int length()                   | 返回对象内容长度                                    |
| public String toString()              | 通过toString()就可以实现把StringBuilder转换为String |

> 对于字符串相关的操作，如频繁的拼接、修改等，建议用StringBuilder，效率更高

5️⃣**StringBuffer**

StringBuffer的用法用StringBuilder时一模一样的

但StringBuilder是线程不安全的，StringBuffer是线程安全的

6️⃣**StringJoiner**

JDK8开始才有的，和StringBuilder一样，也是用来操作字符串的，也可以看成是一个容器，创建之后里面的内容是可变的

好处：不仅能提高字符串的操作效率，并且在有些场景下使用它操作字符串，代码会更简洁

| 构造器                                            | 说明                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| public StringJoiner(间隔符号)                     | 创建一个StringJoiner对象，指定拼接时的间隔符号               |
| public StringJoiner(间隔符号, 开始符号, 结束符号) | 创建一个StringJoiner对象，指定拼接时的间隔符号、开始符号、结束符号 |

| 方法名称                            | 说明                                         |
| ----------------------------------- | -------------------------------------------- |
| public StringJoiner add(添加的内容) | 添加数据，并返回对象本身                     |
| public int length()                 | 返回长度（字符出现的个数）                   |
| public String toString()            | 返回一个字符串（该字符串就是拼接之后的结果） |

7️⃣**Math**：代表数学，是一个工具类，里面提供的都是对数据进行操作的一些静态方法

8️⃣**System**：代表程序所在的系统，也是一个工具类

9️⃣**Runtime**：代表程序所在的运行环境，是一个单例类

🔟⭐**BigDecimal**：用于解决浮点型运算时，出现结果失真的问题（推荐使用传String类型的构造器）

------

### 11. P127 - 137

**JDK8新特性：Lambda表达式** （不能简化全部匿名内部类的方法，==只能简化函数式接口的匿名内部类==）

作用：用于简化匿名内部类的代码写法

```java
// 格式
(被重写方法的形参列表) -> {
	被重写方法的方法体代码;	
}
```

> **函数式接口**：首先是接口，其次有且仅有一个抽象方法的几口
>
> ​						将来见到的大部分函数式接口，上面都可能会有一个 @FunctionalInterface 的注解，有该注解的接口就必定是函数式接口

**Lambda表达式的省略规则**

- 参数类型可以省略不写
- 如果只有一个参数，参数类型可以省略，同时 () 也可以省略
- 如果Lambda表达式中的方法体代码只有一行代码，可以省略大括号不写，同时要省略分号！此时，如果这行代码是return语句，也必须去掉return不写



**JDK8新特性：方法引用**  进一步简化Lambda表达式的

1️⃣**静态方法的引用**  （`::`）

```java
// 格式
类名::静态方法
```

使用场景：如果Lambda表达式里只是调用一个静态方法，并且前后参数的形式一致，就可以使用静态方法引用

2️⃣**实例方法的引用**

```Java
// 格式
对象名::实例方法
```

使用场景：如果某个Lambda表达式里只是调用一个实例方法，并且前后参数的形式一致，就可以使用实例方法引用

3️⃣**特定类型的方法引用**     `类型::方法`

使用场景：如果某个Lambda表达式里只是调用一个实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用

4️⃣**构造器引用**   `类型::new`

使用场景：如果某个Lambda表达式里只是在创建对象，并且前后参数情况一致，就可以使用构造器引用



**排序算法**

1️⃣**冒泡排序**：每次从数组中找出最大值放在数组的后面去

2️⃣**选择排序**：每轮选择当前位置，开始找出后面的较小值与该位置交换

**查找算法**

1️⃣**基本查找/顺序查找**：从头开始遍历查找

2️⃣**二分查找/折半查找**：数组中的数据必须是有序的

​									 	 每次排除一半的数据，查询数据的性能明显提高极多

   

**正则表达式**：就是由一些特定的字符组成，代表的是一个规则

作用：用来校验数据格式是否合法

​			在一段文本中查找满足要求的内容

**正则表达式书写规则**：==查看API文档==

`public boolean matches(String regex)`：判断字符串是否匹配正则表达式，匹配返回true，不匹配返回false

`[]`：只能匹配单个字符

 正则表达式用于搜索替换、分割内容

`public String replaceAll(String regex, Stringh newStr)`：按照正则表达式匹配的内容进行替换

`public String[] split(String regex)`：按照正则表达式匹配的内容进行分割字符串，返回一个字符串数组



**异常**：代表程序中出现的问题

Exception：代表我们的程序可能出现的问题

- ​		运行时异常：RuntimeException及其子类，编译阶段不会出现错误提醒，运行时出现的异常（如：数组索引越界异常）
- ​		编译时异常：编译阶段就会出现错误提醒的（如：日期解析异常）

**解决异常**

- 抛出异常：在方法上使用throws关键字，可以将方法内部出现的异常抛出去给调用者处理

```java
方法 throws 异常1, 异常2, 异常3 .. {
	...
}
```

- 捕获异常 （try ...catch）：直接捕获程序出现的异常

```java
try{
	// 监视可能出现异常的代码
}catch(异常类型1 变量){
	// 处理异常
}catch(异常类型2 变量){
	// 处理异常
}
```



**自定义异常**：继承运行时异常 或者 编译时异常



**异常的处理**

- 捕获异常，记录异常并响应合适的信息给用户
- 捕获异常，尝试重新修复




**集合体系结构**

**1.Collection**：单列集合，每个元素（数据）只包含一个值

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308271702407.png" alt="image-20230827170215259" style="zoom: 80%;" />

**Collection集合特点**

List系列集合：添加的元素是有序、可重复、有索引

Set系列集合：添加的元素是无序、不重复、无索引

​		（1）HashSet：无序、不重复、无索引；

​		（2）LinkedHashSet：有序、 不重复i、无索引；

​		（3）TreeSet：按照大小默认升序排序、不重复、无索引

**Collection的常见方法** （所有单列集合都可以使用的方法）

| 方法名                              | 说明                             |
| ----------------------------------- | -------------------------------- |
| public boolean add(E e)             | 把给定的对象添加到当前集合中     |
| public void clear()                 | 清空集合中所有的元素             |
| public boolean remove(E e)          | 把给定的对象在当前集合中删除     |
| public boolean contains(Object obj) | 判断当前集合中是否包含给定的对象 |
| public boolean isEmpty()            | 判断当前集合是否为空             |
| public int size()                   | 返回集合中元素的个数             |
| public Object[] toArray()           | 把集合中的元素，存储到数组中     |

**Collection的遍历方法**

1️⃣迭代器：是用来遍历集合的专用方式（数组没有迭代器），在Java中迭代器的代表是==Iterator==

​		（1）Collection获取迭代器的方法：`Iterator<E> iterator()`  返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素

​		（2）Iterator迭代器中的常用方法

​				`boolean hasNext()`：询问当前位置是否有元素存在，存在返回true，不存在返回false

​				`E next()`：获取当前位置的元素，并同时将迭代器对象指向下一个元素

2️⃣增强for：既可以遍历集合也可以遍历数组

```java
// 格式
for(元素的数据类型 变量名 : 数组或者集合){
    
}
```

3️⃣lambda表达式：得益于JDK8开始的新技术lambda表达式，提供了一种更简单、更直接的方式来遍历集合。

需要使用Collection的方法来完成：`default void forEach(Consumer<? super T> action)`：结合lambda遍历集合

------

### 12. P138 - 148

**List集合**

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308271805944.png" alt="image-20230827180536788" style="zoom:80%;" />

List集合因为支持索引，所以多了很多==与索引相关==的方法，当然，Collection的功能List也都继承了

| 方法名称                       | 说明                                   |
| ------------------------------ | -------------------------------------- |
| void add(int index, E element) | 在此集合中的指定位置插入指定的元素     |
| E remove(int index)            | 删除指定索引处的元素，返回被删除的元素 |
| E set(int index, E element)    | 修改指定索引出的元素，返回被修改的元素 |
| E get(int index)               | 返回指定索引处的元素                   |

**List集合的遍历方法**

1️⃣for循环（因为List集合有索引）

2️⃣迭代器

3️⃣增强for循环

4️⃣lambda表达式

**ArrayList集合是基于数组实现的**

- 查询速度快：（是根据索引查询数据快）查询数据通过地址值和索引定位，查询任意数据耗时相同
- 删除效率低：可能需要把后面很多的数据进行前移
- 添加效率极低：可能需要把后面很多的数据后移，再添加元素；或者也可以需要进行数组的扩容

**LinkedList集合是基于双链表实现的**

- 查询速度慢：无论查询哪个数据都要从头开始找
- 链表增删相对数组来说速度是快的
- 双向链表对首尾元素进行增删改查的速度是极快的

**LinkedList新增了很多首尾操作的持有方法**

| 方法名称                  | 说明                             |
| ------------------------- | -------------------------------- |
| public void addFirst(E e) | 在该列表开头插入指定的元素       |
| public void addLast(E e)  | 将指定的元素追加到此列表的末尾   |
| public E getFirst()       | 返回此列表中的第一个元素         |
| public E getLast()        | 返回此列表中的最后一个元素       |
| public E removeFirst()    | 从此列表中删除并返回第一个元素   |
| public E removeLast()     | 从此列表中删除并返回最后一个元素 |

**LinkedList的应用场景**

- 设计==队列==：先进先出，后进后出
- 设计==栈==：后进先出，先进后出



**Set集合**

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308271905323.png" alt="image-20230827190511233" style="zoom:80%;" />

> Set要用到的常用方法，基本上就是Collection提供的。自己几乎没有额外新增一些常用功能

**HashSet集合基于哈希表实现的**：数组 + 链表 + ==红黑树==

> 哈希值：就是一个int类型的数值，Java中每个对象都有一个哈希值

哈希表是一种增删改查数据，性能都较好的数据结构

JDK8开始，当链表长度超过8，且数组长度 >= 64，自动将链表转成红黑树，进一步提高了操作数据的性能

**树**

- 二叉树中，任意节点的度 <= 2
- 度：每个节点的子节点数量
- 树高：树的总层数
- 根节点：最顶层的节点
- 左子节点、右子节点、左子树、右子树

> Java中用的多的为**二叉查找树**（二叉排序树），其规则为：小的存左边，大的存右边，一样的不存
>

已排序好的数组使用二叉查找树，可能会导致查询性能变差，可使用平衡二叉树（左子树长度-右子树长度<=1）解决。

**红黑树**：就是可以自平衡的二叉树，是一种增删改查数据性能相对都较好的结构

> HashSet集合默认不能对内容一样的两个对象去重复，比如内容一样的两个学生对象存入到HashSet集合中去，HashSet集合是不能去重复的。这个时候就必须重写对象的hashCode()和equals()方法进行去重。



**LinkedHashSet集合是基于哈希表（数组、链表、红黑树）实现的**，但是，它的每个元素都额外的多了一个==双链表==的机制记录它前后元素的位置



**TreeSet集合是基于红黑树实现的**：不重复、无索引、可排序（默认升序排序，按照元素的大小，由小到大排序）

**注意**：对于数值类型：Integer、Double，默认按照数值本身的大小进行升序排序

​			对于字符串类型：默认按照首字符的编号升序排序

​			==对于自定义类型如Student对象，TreeSet默认是无法直接排序的==

**TreeSet集合存储自定义类型的对象时，必须指定排序规则，支持如下两种方式指定比较规则**：

- 让自定义的类（如学生类）实现Comparable接口，重写里面的CompartTo方法来指定比较规则
- 通过调用TreeSet集合有参数构造器，可以设置Comparator对象（比较器对象，用于指定比较规则） 

​		`public TreeSet(Comparator<? super E> comparator)`

> 两种方式中，返回值的规则：
>
> - ​		如果认为第一个元素 > 第二个元素 返回正整数
> - ​		如果认为第一个元素 < 第二个元素 返回负整数
> - ​		如果认为第一个元素 = 第二个元素 返回0，此时TreeSet集合只会保留一个元素，认为两者重复



**集合的并发修改异常**

- 使用迭代器遍历集合时，又同时删除集合中的数据，程序就会出现并发修改异常的错误
- 由于增强for循环遍历集合就是迭代器遍历集合的简化写法，因此，使用增强for循环遍历集合，又在同时删除集合中的数据时，程序也会出现并发修改异常的错误

**解决**

- 使用迭代器遍历集合，但用迭代器自己的删除方法删除数据即可
- 如果能用for循环遍历时：可以倒着遍历并删除；或者从前往后遍历，但删除元素后做 i-- 操作



**总结**

1.如果希望记住元素的添加顺序，需要存储重复的元素，又要频繁的根据索引查询数据：**用ArrayList集合（有序、可重复、有索引）**，底层基于数组。（==常用==）

2.如果希望记住元素的添加顺序，且增删首尾数据的情况较多：用**LinkedList集合（有序、可重复、有索引）**，底层基于双链表

3.如果不在意元素顺序，也没有重复元素需要存储，只希望增删改查都快：**用HashSet集合（无序、不重复、无索引）**，底层基于哈希表实现。（==常用==）

4.如果希望记住元素的添加顺序，也没有重复的元素需要存储，且希望增删改查都快：**用LinkedHashSet集合（有序、不重复、无索引）**，底层基于哈希表和双链表

5.如果要对元素进行排序，也没有重复的元素需要存储，且希望增删改查都快：**用TreeSet集合**，基于红黑树实现



**可变参数**

- 定义：就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：`数据类型...参数名称;`
- 特点：可以不传数据给它；可以传一个或者同时传多个数据给它；也可以传一个数组给它
- 好处：常常用来灵活的接收数据

> 注意事项：
>
> - 一个形参列表中，只能有一个可变参数
> - 可变参数必须放在形参列表的最后面



**Collections**

用来操作集合的工具类

| 方法名称                                                     | 说明                                               |
| ------------------------------------------------------------ | -------------------------------------------------- |
| public static <T> boolean addAll(Collection<? super T> c, T...elements) | 给集合批量添加元素                                 |
| public static void shuffle(List<?> list)                     | 打乱List集合中的元素顺序                           |
| public static <T> void sort(List<T> list)                    | 对List集合中的元素进行升序排序                     |
| public static <T> void sort(List<T> list, Comparator<? super T> c) | 对List集合中元素，按照比较器对象指定的规则进行排序 |



**2. Map**：双列集合，每个元素包含两个值（键值对）

Map集合称为双列集合，格式：`{key1=value1,key2=value2,key3=value3，...，}`一次需要存一对数据做为一个元素

Map集合的每个元素“key=value”称为一个键值对/键值对对象 /一个Entry对象，Map集合也被叫做" 键值对集合 "

Map集合的所有键是不允许重复的，但值可以重复，键和值是==一一对应==的，每一个键只能找到自己对应的值

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308281717901.png" alt="image-20230828171703823" style="zoom:80%;" />

 **Map集合体系的特点**

> **注意：Map系列集合的特点都是由键决定的，值只是一个附属品，值是不做要求的**

- HashMap（由键决定特点）：无序、不重复、无索引  （==用的最多==）
- LinkedHashMap（由键决定特点）：有序、不重复、无索引
- TreeMap（由键决定特点）：==按照大小默认升序排序==、不重复、无索引

**Map集合常见方法**

| 方法名称                                   | 说明                                   |
| ------------------------------------------ | -------------------------------------- |
| public int size()                          | 获取集合的大小                         |
| public void clear()                        | 清空集合                               |
| public boolean isEmpty()                   | 判断集合是否为空，为空返回true ，反之  |
| public V get(Object key)                   | 根据健获取对应值                       |
| public V remove(object key)                | 根据健删除整个元素(删除健会返回键的值) |
| public boolean containsKey(object key)     | 判断是否包含某个键 ，包含返true ,反之  |
| public boolean containsValue(object value) | 判断是否包含某个值                     |
| public Set<K> keySet()                     | 获取Map集合的全部键                    |
| public ColLection<V> vaLues()              | 获取Map集合的全部值                    |
| public V put(K key, V value)               | 添加元素                               |
| putAll()                                   | 把其他Map集合的数据倒入到自己集合中来  |



**Map集合的遍历方式**

- 键找值：先获取Map集合全部的键，再通过遍历键来找值
- 键值对：把“键值对”看成一个整体进行遍历（难度较大）

`Set<Map.Entry<K, V>> entrySet()`：获取所有“键值对”的集合

- Lambda：JDK1.8开始之后的新技术

`default void forEach(BiConsumer<? super K，? super V> action)`：结合lambda遍历Map集合

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308281946479.png" alt="image-20230828194653416" style="zoom:80%;" />



**HashMap集合是基于哈希表实现的**

- HashMap集合是一种增删改查数据，性能都较好的集合
- 但是它是无序，不能重复，没有索引支持的(由键决定特点)
- HashMap的键依赖hashCode方法和equals方法保证键的唯一

- 如果键存储的是自定义类型的对象，可以通过重写hashCode和equals方法，这样可以保证多个对象内容一样时，HashMap集合就能认为是重复的



**LinkedHashMap集合是基于哈希表实现的**：额外多了双链表

**TreeMap集合是基于红黑树实现的**

指定排序规则：让类实现Comparable接口，重写比较规则

​			           	TreeMap集合有一个有参数构造器，支持创建Comparator比较器对象，以便用来指定比较规则			

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308282021793.png" alt="image-20230828202135742" style="zoom:80%;" />



**集合的嵌套**：集合中的元素又是一个集合

------

### 13. P149 - 158

**Stream**

- 定义：也叫Stream流，是dk8开始新增的一套API(iavautil.stream.*)，==可以用于操作集合或者数组的数据==
- 优势：==Stream流大量的结合了Lambda的语法风格来编程==，提供了一种更加强大，更加简单的方式操作集合或者数组中的数据，==代码更简洁，可读性更好==

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308282032589.png" alt="image-20230828203245544" style="zoom:80%;" />

**Stream流使用步骤**：

- 数据源（集合/数组/...）
- 获取Stream流：Stream流代表一条流水线，并能与数据源建立连接。支持链式（过滤、排序、去重、...）==中间方法==
- 获取结果  ==终结方法==

**Stream流的常见方法**

`default Stream<E> stream( )`  ：获取当前==集合==对象的stream流 （Collection提供的）

`public static <T> Stream<T> stream(T[] array)`：获取当前==数组==的stream流  （Arrays类提供的）

`public static<T> Stream<T> of(T... values)`：获取当前接收==数组==的stream流  （Stream类提供的）

**中间方法**：指的是调用完成后会返回新的Stream流，可以继续使用(支持链式编程)

| Stream提供的常用的中间方法                                | 说明                             |
| --------------------------------------------------------- | -------------------------------- |
| Stream<T> filter(Predicate<? super T> predicate)          | 用于对流中的数据进行过滤         |
| Stream<T> sorted()                                        | 对元素进行升序排序               |
| Stream<T> sorted(Comparator<? super T> comparator)        | 按照指定规则排序                 |
| Stream<T> limit(long maxSize)                             | 获取前几个元素                   |
| Stream<T> skip(long n)                                    | 跳过前几个元素                   |
| Stream<T> distinct()                                      | 去除流中重复的元素               |
| <R> Stream<R> map(Function<? super T,? extends R> mapper) | 对元素进行加工，并返回对应的新流 |
| static <T> Stream<T> concat(Stream a， Stream b)          | 合并a和b两个流为一个流           |

**终结方法**：指的是调用完成后，不会返回新Stream了，没法继续使用流了

| Stream提供的常用的终结方法                        | 说明                       |
| ------------------------------------------------- | -------------------------- |
| void forEach(Consumer action)                     | 对此流运算后的元素执行遍历 |
| long count()                                      | 统计此流运算后的元素个数   |
| Optional<T> max(Comparator<? super T> comparator  | 获取此流运算后的最大值元素 |
| Optional<I> min(Comparator<? super T> comparator) | 获取此流运算后的最小值元素 |



**收集Stream流**：就是把Stream流操作后的结果转回到集合或者数组中去返回（==流只能收集一次，链式收集==）

Stream流：方便操作集合/数组的==手段==              集合/数组：才是开发中的==目的==

| Stream提供的常用的终结方法     | 说明                                     |
| ------------------------------ | ---------------------------------------- |
| R collect(Collector collector) | 把流处理后的结果收集到一个指定的集合中去 |
| Object[] toArray()             | 把流处理后的结果收集到一个数组中去       |

| Collectors工具类提供了具体的收集方式                         | 说明                   |
| ------------------------------------------------------------ | ---------------------- |
| public static <T> Collector toList()                         | 把元素收集到List集合中 |
| public static <T> Collector toSet()                          | 把元素收集到Set集合中  |
| public static Collector toMap(Function keyMapper ,Function valueMapper) | 把元索收集到Map集合中  |



**File、IO流**

 File：代表文本   IO流：读写数据

- 文件是非常重要的存储方式，在计算机硬盘中
- 即便断电，或者程序终止了，存储在硬盘文件中的数据也不会丢失

**File**

File是java.io.包下的类，File类的对象，用于代表当前操作系统的文件 (可以是==文件、或文件夹==)

> **注意：File类只能对文件本身进行操作，不能读写文件里面存储的数据**

**创建File类的对象**

| 构造器                                   | 说明                                           |
| ---------------------------------------- | ---------------------------------------------- |
| public File(String pathname)             | 根据文件路径创建文件对象                       |
| public File(String parent，String child) | 根据父路径和子路径名字创建文件对象             |
| public File(File parent，String child)   | 根据父路径对应文件对象和子路径名字创建文件对象 |

> 注意：
>
> ​		File对象既可以代表文件、也可以代表文件夹
>
> ​		File封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的

**File提供的判断文件类型、获取文件信息功能**

| 方法名称                        | 说明                                                       |
| ------------------------------- | ---------------------------------------------------------- |
| public boolean exists()         | 判断当前文件对象，对应的文件路径是否存在，存在返回true     |
| public boolean isFile()         | 判断当前文件对象指代的是否是文件，是文件返回true，反之     |
| public boolean isDirectory()    | 判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之 |
| public String getName()         | 获取文件的名称（包含后缀）                                 |
| public long length()            | 获取文件的大小，返回字节个数                               |
| public long lastModified()      | 获取文件的最后修改时间                                     |
| public String getPath()         | 获取创建文件对象时，使用的路径                             |
| public String getAbsolutePath() | 获取绝对路径                                               |

**File提供的创建文件、删除文件的方法**

| 方法名称                       | 说明                                                  |
| ------------------------------ | ----------------------------------------------------- |
| public boolean createNewFile() | 创建一个新文件 (文件内容为空)，创建成功返回true，反之 |
| public boolean mkdir()         | 用于创建文件夹，注意: 只能创建一级文件夹              |
| public boolean mkdirs()        | 用于创建文件夹，注意: 可以创建多级文件夹              |
| public boolean delete()        | 删除文件，或者空文件，注意：**不能删除非空文件夹**    |

**File提供的遍历文件夹的方法**

| 方法名称                  | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| public String[] list()    | 获取当前目录下所有的”一级文件名称"到一个字符串数组中去返回   |
| public File[] ListFiles() | 获取当前目录下所有的"一级文件对象"到一个文件对象数组中去返回(重点) |

**使用listFiles方法时的注意事项**

- 当主调是文件，或者路径不存在时，返回null
- 当主调是空文件夹时，返回一个长度为0的数组
- 当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回
- 当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件
- 当主调是一个文件夹，但是没有权限访问该文件夹时，返回null



**方法递归**

定义：递归是一种算法，在程序设计语言中广泛应用。方法调用自身的形式称为方法递归(recursion)

递归的形式：直接递归，方法自己调用自己

​						间接递归，方法调用其他方法，其他方法又回调方法自己

**使用递归时需要注意的问题**：递归如果没有控制好终止，会出现递归死循环，导致栈内存溢出错误



**字符集**

**标准ASCII字符集**

- ASCII(American tandard Code forlnformation lnterchange)，美国信息交换标准代码，包括了英文、符号等
- 标准ASCII使用==1个字节==存储一个字符，首尾是0，总共可表示128个字符，对美国佬来说完全够用

**GBK (汉字内码扩展规范，国标)**

- 汉字编码字符集，包含了2万多个汉字等字符，GBK中一个中文字符编码成两个字节的形式存储
- 注意：GBK兼容了ASCII字符集

> GBK规定: 汉字的第一个字节的第一位必须是 1

**Unicode字符集(统一码，也叫万国码)**

Unicode是国际组织制定的，可以容纳世界上所有文字、符号的字符集

**UTF-8**

是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区:1个字节，2个字节，3个字节，4个字节

==英文字符、数字等只占1个字节 (兼容标准ASCII编码)，汉字字符占用3个字节==

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308291037816.png" alt="image-20230829103702731" style="zoom:80%;" />

> **注意：技术人员在开发时都应该使用UTF-8编码！**

**总结**

- ASCII字符集：只有英文、数字、符号等，占1个字节
- GBK字符集：汉字占2个字节，英文、数字占1个字节
- UTF-8字符集：汉字占3个字节，英文、数字占1个字节

> **注意：**
>
> ​		字符编码时使用的字符集，和解码时使用的字符集必须一致，==否则会出现乱码==
>
> ​		英文，数字一般不会乱码，因为很多字符集都兼容了ASCII编码



**字符集的编码、解码操作**

Java代码完成对字符的解码

| String提供如下方法                  | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| byte[] getBytes()                   | 使用平台的默认字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 |
| byte[] getBytes(String charsetName) | 使用指定的字符集将该 string编码为一系列字节，将结果存储到新的字节数组中 |

Java代码完成对字符的解码

| String提供如下方法                       | 说明                                                        |
| ---------------------------------------- | ----------------------------------------------------------- |
| String(byte[] bytes)                     | 通过使用平台的默认字符集解码指定的字节数组来构造新的 String |
| String(byte[] bytes，String charsetName) | 通过指定的字符集解码指定的字节数组来构造新的 String         |



**IO流**

- 用于==读写数据==的（可以读写文件，或网络中的数据...）

- I指Input，称为输入流：负责把数据读到内存中去

- 0指Output，称为输出流：负责写数据出去

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308291416451.png" alt="image-20230829141657364" style="zoom:80%;" />

**总结流的四大类**

- 字节输入流：以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流
- 字节输出流：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流
- 字符输入流：以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流
- 字符输出流：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308291420089.png" alt="image-20230829142018035" style="zoom:80%;" />



**FilelnputStream(文件字节输入流)**

作用：以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去

| 构造器                                  | 说明                           |
| --------------------------------------- | ------------------------------ |
| public FileInputStream(File file)       | 创建字节输入流管道与源文件接通 |
| public FileInputStream(String pathname) | 创建字节输入流管道与源文件接通 |

| 方法名称                       | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| public int read()              | 每次读取一个字节返回，如果发现没有数据可读会返回-1（一个字节） |
| public int read(byte[] buffer) | 每次用一个字节数组去读取数据，返回字节数组读取了多少个字节如果发现没有数据可读会返回-1（多个字节） |

> 注意：流使用完毕之后，必须关闭，释放系统资源！
>
> ​			使用FilelnputStream每次读取一个字节，读取性能较差，并且读取汉字输出会乱码

**一次读取完全部字节**（文件过大，可能引起内存溢出）

**方式一**：自己定义一个字节数组与被读取的文件大小一样大，然后使用该字节数组，一次读完文件的全部字节

**方式二**：Java官方为inputStream提供了如下方法，可以直接把文件的全部字节读取到一个字节数组中返回

| 方法名称                                        | 说明                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| public byte[] readAllBytes() throws IOException | 直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回 |

------

### 14. P159 - 168

**FileOutputStream(文件字节输出流)**

作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去

| 构造器                                                  | 说明                                           |
| ------------------------------------------------------- | ---------------------------------------------- |
| public FileOutputStream(File file)                      | 创建字节输出流管道与源文件对象接通             |
| public FileOutputStream(String filepath)                | 创建字节输出流管道与源文件路径接通             |
| public FileOutputStream(File file，boolean append)      | 创建字节输出流管道与源文件对象接通，可追加数据 |
| public FileOutputStream(String filepath, boolean append | 创建字节输出流管道与源文件路径接通，可追加数据 |

| 方法名称                                           | 说明                       |
| -------------------------------------------------- | -------------------------- |
| public void write(int a)                           | 写一个字节出去             |
| public void write(byte[] buffer)                   | 写一个字节数组出去         |
| public void write(byte[] buffer ,int pos ,int len) | 写一个字节数组的一部分出去 |
| public void close() throws IOException             | 关闭流                     |

> 字节流非常适合做一切文件的复制操作。任何文件的底层都是字节，字节流做复制，是一字不漏的转移完全部字节，只要复制后的文件格式一致就没问题



**释放资源**

1️⃣**try-catch-finally**

```java 
try{
	...
	...
}catch(IOException e){
	e.printStackTrace();
}finally{

}
```

- finally代码区的特点：无论try中的程序是正常执行了，还是出现了异常，最后都一定会执行finally区，除非JVM终止 （不能return数据）
- 作用：一般用于在程序执行完成后进行资源的释放操作（专业级做法）

**2️⃣try-with-resource**：JDK7开始提供了更简单的资源释放方案（该资源使用完毕后，会自动调用其close()方法，完成对资源的释放）

```java
try(定义资源1; 定义资源2; ...){  // ()中只能放置资源，否则报错
	可能出现异常的代码;			// 资源一般指的是最终实现了AutoCloseable接口
}catch(异常类名 变量名){
	异常的代码处理;
}
```

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308291619948.png" alt="image-20230829161948891" style="zoom:80%;" />



**字符流**：适合读写文本文件的内容

**FileReader(文件字符输入流)**

作用：以内存为基准，可以把文件中的数据以字符的形式读入到内存中去

| 构造器                             | 说明                           |
| ---------------------------------- | ------------------------------ |
| public FileReader(File file)       | 创建字符输入流管道与源文件接通 |
| public FileReader(String pathname) | 创建字符输入流管道与源文件接通 |

| 方法名称                       | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| public int read()              | 每次读取一个字符返回，如果发现没有数据可读会返回-1           |
| public int read(char[] buffer) | 每次用一个字符数组去读取数据，返回字符数组读取了多少个字符如果发现没有数据可读会返回-1 |

**FileWriter(文件字符输出流)**

作用：以内存为基准，把内存中的数据以字符的形式写出到文件中去

| 构造器                                             | 说明                                               |
| -------------------------------------------------- | -------------------------------------------------- |
| public Filewriter(File file)                       | 创建字节输出流管道与源文件**对象**接通             |
| public FileWriter(string filepath)                 | 创建字节输出流管道与源文件**路径**接通             |
| public FileWriter(File file，boolean append)       | 创建字节输出流管道与源文件**对象**接通，可追加数据 |
| public FileWriter(String filepath，boolean append) | 创建字节输出流管道与源文件**路径**接通，可追加数据 |

| 方法名称                                 | 说明                 |
| ---------------------------------------- | -------------------- |
| void write(int c)                        | 写一个字符           |
| void write(String str)                   | 写一个字符串         |
| void write(String str, int off, int len) | 写一个字符串的一部分 |
| void write(charl] cbuf)                  | 写入一个字符数组     |
| void write(charl] cbuf int off, int len) | 写入字符数组的一部分 |

字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效

| 方法名称                               | 说明                                               |
| -------------------------------------- | -------------------------------------------------- |
| public void flush() throws IOException | 刷新流，就是将内存中缓存的数据立即写到文件中去生效 |
| public void close() throws IOException | 关闭流的操作，包含了刷新                           |

**字节流、字符流的使用场景小结**

- 字节流适合做一切文件数据的拷贝(音视频，文本)；字节流不适合读取中文内容输出
- 字符流适合做文本文件的操作(读，写)



**缓冲流**

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308291652148.png" alt="image-20230829165258093" style="zoom:80%;" />

作用：对原始流进行包装，以提高原始流读写数据的性能

**字节缓冲流**：

- 作用：提高字节流读写数据的性能
- 原理：字节缓冲输入流自带了==8KB缓冲池==；字节缓冲输出流也自带了==8KB缓冲池==

| 构造器                                       | 说明                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| public BufferedInputStream(InputStream is)   | 把低级的字节输入流包装成一个高级的缓冲字节输入流，从而提高读数据的性能 |
| public BufferedOutputStream(OutputStream os) | 把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能 |

**字符缓冲流**：

**BufferedReader(字符缓冲输入流)**

作用：自带8K (8192)的字符缓冲池，可以提高字符输入流读取字符数据的性能

| 构造器                          | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| public BufferedReader(Reader r) | 把低级的字符输入流包装成字符缓冲输入流管道，从而提高字符输入流读字符数据的性能 |

**字符缓冲输入流新增的功能：按照行读取字符**

| 方法                     | 说明                                             |
| ------------------------ | ------------------------------------------------ |
| public String readLine() | 读取一行数据返回，如果没有数据可读了，会返回null |

**BufferedWriter(字符缓冲输出流)**

作用：自带8K的字符缓冲池，可以提高字符输出流写字符数据的性能

| 构造器                          | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| public Bufferedwriter(writer r) | 把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能 |

**字符缓冲输出流新增的功能：换行**

| 方法                  | 说明 |
| --------------------- | ---- |
| public void newLine() | 换行 |



**转换流**

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308291906037.png" alt="image-20230829190608966" style="zoom:80%;" />

1️⃣**不同编码读取时会乱码**

如果==代码编码==和被读取的==文本文件的编码是一致的==，使用==字符流读取==文本文件时==不会出现乱码==

如果==代码编码==和被读取的==文本文件的编码是不一致的==，使用==字符流读取==文本文件时就==会出现乱码==

2️⃣**字符输入转换流**

**InputStreamReader(字符输入转换流)**

- 解决不同编码时，字符流读取文本内容乱码的问题
- 解决思路：先获取文件的原始字节流，再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了

| 构造器                                                       | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| public InputStreamReader (Inputstream is)                    | 把原始的字节输入流，按照代码默认编码转成字符输入流 (与直接用FileReader的效果一样) |
| ==public InputStreamReader(InputStream is ，String charset)== | 把原始的字节输入流，按照指定字符集编码转成字符输入流(**重点**) |

3️⃣**字符输出转换流**

**OutputStreamWriter字符输出转换流**

- 作用：可以控制写出去的字符使用什么字符集编码
- 解决思路：获取字节输出流，再按照指定的字符集编码将其转换成字符输出流，以后写出去的字符就会用该字符集编码了

| 构造器                                                       | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| public OutputStreamWriter(OutputStream os)                   | 可以把原始的字节输出流，按照代码默认编码转换成字符输出流     |
| ==public 0utputstreamwriter(0utputstream os，String charset)== | 可以把原始的字节输出流，按照指定编码转换成字符输出流            **重点** |



**打印流**

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308291911964.png" alt="image-20230829191158901" style="zoom:80%;" />

**PrintStream/PrintWriter(打印流)**

作用：打印流可以实现更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去

**PrintStream提供的打印数据的方案**

| 构造器                                                       | 说明                                     |
| ------------------------------------------------------------ | ---------------------------------------- |
| public ==PrintStream==(OutputStream/File/==string==)         | 打印流直接通向字节输出流/文件/文件路径   |
| public PrintStream(String fileName, Charset charset)         | 可以指定写出去的字符编码                 |
| public PrintStream(OutputStream out，boolean autoFlush)      | 可以指定实现自动刷新                     |
| public PrintStream(0utputStream outboolean autoFlush,String encoding) | 可以指定实现自动刷新，并可指定字符的编码 |

| 方法                                       | 说明                       |
| ------------------------------------------ | -------------------------- |
| public void println(Xxx xx)                | 打印任意类型的数据出去     |
| public void write(int/byte[]/byte[]一部分) | 可以支持写==字节==数据出去 |

**PrintWriter提供的打印数据的方案**

| 构造器                                                       | 说明                                     |
| ------------------------------------------------------------ | ---------------------------------------- |
| public PrintWriter(OutputStream/Writer/File/String)          | 打印流直接通向字节输出流/文件/文件路径   |
| public PrintWriter(String fileName， Charset charset)        | 可以指定写出去的字符编码                 |
| public PrintWriter(OutputStream out/Writer,boolean autoFlush) | 可以指定实现自动刷新                     |
| public Printwriter(OutputStream out, boolean autoFlush,String encoding) | 可以指定实现自动刷新，并可指定字符的编码 |

**PrintStream和PrintWriter的区别**

- 打印数据的功能上是一模一样的：==都是使用方便，性能高效 (核心优势)==
- PrintStream继承自字节输出流OutputStream，因此支持写字节数据的方法
- PrintWriter继承自字符输出流Writer，因此支持写字符数据出去

> 应用——输出语句的重定向  setOut()



**数据流**

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308291953015.png" alt="image-20230829195318951" style="zoom:80%;" />

**DataOutputStream(数据输出流)**

允许把数据和其类型一并写出去

| 构造器                                    | 说明                                 |
| ----------------------------------------- | ------------------------------------ |
| public DataOutputStream(OutputStream out) | 创建新数据输出流包装基础的字节输出流 |

| 方法                                                       | 说明                                              |
| ---------------------------------------------------------- | ------------------------------------------------- |
| public final void writeByte(int v) throws IOException      | 将byte类型的数据写入基础的字节输出流              |
| public final void writeInt(int v) throws IOException       | 将int类型的数据写入基础的字节输出流               |
| public final void writeDouble(Double v) throws IOException | 将double类型的数据写入基础的字节输出流            |
| public final void writeUTF(String str) throws IOException  | 将字符串数据以UTF-8编码成字节写入基础的字节输出流 |
| public void write(int/byte[]/byte[]一部分)                 | 支持写字节数据出去                                |

**DatalnputStream(数据输入流)**

用于读取数据输出流写出去的数据

| 构造器                                 | 说明                                 |
| -------------------------------------- | ------------------------------------ |
| public DataInputstream(Inputstream is) | 创建新数据输入流包装基础的字节输入流 |

| 方法                                                | 说明                      |
| --------------------------------------------------- | ------------------------- |
| Public final byte readByte() throws IOException     | 读取字节数据返回          |
| public final int readInt() throws IOException       | 读取int类型的数据返回     |
| public final double readDouble() throws IOException | 读取double类型的数据返回  |
| public final String readUTF() throws IOException    | 读取字符串数(UTF-8)据返回 |
| public int readInt()/read(byte[])                   | 支持读字节数据进来        |



**序列化流**

对象序列化：把ava对象写入到文件中去

对象反序列化：把文件里的lava对象读出来

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308292003661.png" alt="image-20230829200333593" style="zoom:80%;" />

**ObjectOutputStream(对象字节输出流)**

可以把Java对象进行序列化：把Java对象存入到文件中去

| 构造器                                      | 说明                                     |
| ------------------------------------------- | ---------------------------------------- |
| public ObjectOutputstream(Outputstream out) | 创建对象字节输出流，包装基础的字节输出流 |

| 方法                                                       | 说明         |
| ---------------------------------------------------------- | ------------ |
| public final void writeObject(Object o) throws IOException | 把对象写出去 |

> 注意:：对象如果要参与序列化，必须实现序列化接口 (java.io.Serializable)

**ObjectlnputStream(对象字节输入流)**

可以把Java对象进行反序列化：把存储在文件中的Java对象读入到内存中来

| 构造器                                   | 说明                                     |
| ---------------------------------------- | ---------------------------------------- |
| public ObjectInputStream(Inputstream is) | 创建对象字节输入流，包装基础的字节输入流 |

| 方法                             | 说明                           |
| -------------------------------- | ------------------------------ |
| public final object readObject() | 把存储在文件中的Java对象读出来 |

> 用一个ArrayList集合存储多个对象，然后直接对集合进行序列化即可
>
> 注意：ArrayList集合已经实现了序列化接口



**IO框架**

- 框架：解决某类问题，编写的一套类、接口等，可以理解成一个半成品，大多框架都是第三方研发的
- 好处：在框架的基础上开发，可以得到优秀的软件架构，并能提高开发效率
- 框架的形式：一般是把类、接口等编译成class形式，再压缩成一个.jar结尾的文件发行出去
- **IO框架**：封装了Java提供的对文件、数据进行操作的代码，对外提供了更简单的方式来对文件进行操作，对数据进行读写等

**1️⃣Commons-io**

Commons-io是apache开源基金组织提供的一组有关IO操作的小框架，目的是提高IO流的开发效率

| FileUtils类提供的部分方法展示                                | 说明       |
| ------------------------------------------------------------ | ---------- |
| public static void copyFile(File srcFile, File destFile)     | 复制文件   |
| public static void copyDirectory(File srcDir， File destDir) | 复制文件夹 |
| public static void deleteDirectory(File directory)           | 删除文件夹 |
| public static String readFileToString(File file, String encoding) | 读数据     |
| public static void writeStringToFile(File file, String data, String charname, boolean append) | 写数据     |

| loUtils类提供的部分方法展示                                  | 说明     |
| ------------------------------------------------------------ | -------- |
| public static int copy(InputStream inputStream, OutputStream outputStream) | 复制文件 |
| public static int copy(Reader reader, Writer writer)         | 复制文件 |
| public static void write(String data, OutputStream output, String charsetName) | 写数据   |

**IDEA导入jar包**

1. 下载jar包
2. 工程新建Directory，一般命名为lib（用于存放库/jar包）
3. 将下载完成的jar包复制粘贴到lib目录下
4. 右键lib目录，选择 **Add as Library**  ->  点击OK

------

### 15. P169 - 180

**特殊文件：Properties属性文件**

特点：

1. 都只能是键值对
2. 键不能重复
3. 文件后缀一般是.properties结尾的

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308292100476.png" alt="image-20230829210000426" style="zoom:80%;" />

**Properties**

- 是一个Map集合(键值对集合)，但是我们一般不会当集合使用
- 核心作用：Properties是用来代表属性文件的，通过Properties可以读写属性文件里的内容

**使用Properties读取属性文件里的键值对数据**

| 构造器              | 说明                               |
| ------------------- | ---------------------------------- |
| public Properties() | 用于构建Properties集合对象(空容器) |

| 常用方法                                 | 说明                                       |
| ---------------------------------------- | ------------------------------------------ |
| public void load(InputStream is)         | 通过字节输入流，读取属性文件里的键值对数据 |
| public void load(Reader reader)          | 通过字符输入流，读取属性文件里的键值对数据 |
| public String getProperty(String key)    | 根据键获取值(其实就是get方法的效果)        |
| public Set<String> stringPropertyNames() | 获取全部键的集合(其实就是ketSet方法的效果) |

**使用Properties把键值对数据写出到属性文件里去**

构造器同上

| 常用方法                                            | 说明                                           |
| --------------------------------------------------- | ---------------------------------------------- |
| public Object setProperty(String key, String value) | 保存键值对数据到Properties对象中去             |
| public void store(OutputStream os, String comments) | 把键值对数据，通过字节输出流写出到属性文件里去 |
| public void store(Writer w, String comments)        | 把键值对数据，通过字符输出流写出到属性文件里去 |



**特殊文件：XML文件**

**XML**( 全称EXtensible Markup Language，可扩展标记语言 )：本质是一种数据的格式，可以用来存储复杂的数据结构，和数据关系

**特点**：XML中的“<标签名>” 称为一个标签或一个元素，一般是成对出现的

​			XML中的标签名可以自己定义 (可扩展)，但必须要正确的嵌套

​			XML中只能有一个根标签

​			XML中的标签可以有属性

​			如果一个文件中放置的是XML格式的数据，这个文件就是XML文件，后缀一般要写成.xml

**XML的语法规则**

- XML文件的后缀名为：xml，文档声明必须是第一行

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308292120328.png" alt="image-20230829212016291" style="zoom:80%;" />

- XML中可以定义注释信息：<!-- 注释内容 -->
- XML中书写”<”  “&”等，可能会出现冲突，导致报错，此时可以用如下特殊字符替代

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308292120836.png" alt="image-20230829212029804" style="zoom:80%;" />

- XML中可以写一个叫CDATA的数据区：<![CDATA[...内容... ]l>，里面的内容可以随便写

**XML的作用和应用场景**

- 本质是一种数据格式，可以存储复杂的数据结构，和数据关系
- 应用场景：经常用来做为系统的==配置文件==，或者作为一种特殊的数据结构，在网络中进行传输。

**读取XML文件中的数据/解析XML文件**

> **注意**：程序员并不需要自己写原始的IO流代码来解析XML，难度较大!也相当繁琐! 、
>
> ​			其实，有很多开源的，好用的，解析XML的框架，==最知名的是: Dom4j(第三方研发的)==
>
> 
>
> **使用Dom4J解析出XML文件**
>
> - 下载Dom4j框架，官网下载
> - 在项目中创建一个文件夹：lib
> - 将dom4j-2.1.3.jar文件复制到 lib 文件夹
> - 在jar文件上点右键，选择Add as Library -> 点击OK
> - 在类中导包使用

**Dom4j解析XML-得到Document对象**

- SAXReader: Dom4j提供的解析器，可以认为是代表整个Dom4j框架

| 构造器/方法                          | 说明                      |
| ------------------------------------ | ------------------------- |
| public SAXReader()                   | 构建Dom4J的解析器对象     |
| public Document read(String url)     | 把XML文件读成Document对象 |
| public Document read(InputStream is) | 通过字节输入流读取XML文件 |

- Document

| 方法名                  | 说明           |
| ----------------------- | -------------- |
| Element getRootElement0 | 获得根元素对象 |

**Element提供的方法**

| 方法名                                     | 说明                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| public String getName()                    | 得到元素名字                                                 |
| public List<Element> elements()            | 得到当前元素下所有子元素                                     |
| public List<Element> elements(String name) | 得到当前元素下指定名字的子元素返回集合                       |
| public Element element(String name)        | 得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个 |
| public String attributeValue(String name)  | 通过属性名直接得到属性值                                     |
| public string elementText(子元素名)        | 得到指定名称的子元素的文本                                   |
| public String getText()                    | 得到文本                                                     |

> 推荐直接把程序里的数据拼接成XML格式，然后用IO流写出去

**约束XML文件的书写**：就是限制XML文件只能按照某种格式进行书写

**约束文档**：专门用来限制xml书写格式的文档，比如:限制标签、属性应该怎么写

**约束文档的分类**

- **DTD文档**

（1）编写DTD约束文档，后缀必须是dtd

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308292150622.png" alt="image-20230829215041580" style="zoom:80%;" />

（2）在需要编写的XML文件中导入该DTD约束文档

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308292151163.png" alt="image-20230829215154129" style="zoom:80%;" />

（3）然后XML文件，就必须按照DTD约束文档指定的格式进行编写，否则报错!

- **Schema文档**

（1）编写schema约束文档，后缀必须是xsd，具体的形式到代码中观看

（2）在需要编写的XML文件中导入该schema约束文档

（3）按照约束内容编写XML文件的标签



**日志技术**

- 可以将系统执行的信息，方便的记录到指定的位置(控制台、文件中、数据库中)
- 可以随时以开关的形式控制日志的启停，无需侵入到源代码中去进行修改

> **日志**
>
> - 好比生活中的日记，可以记录你生活中的点点滴滴
> - 程序中的日志，通常就是一个文件，里面记录的是程序运行过程中的各种信息

**日志技术的体系结构**

**日志框架**：牛人或者第三方公司已经做好的实现代码，后来者直接可以拿去使用

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308300936905.png" alt="image-20230830093649813" style="zoom:80%;" />

**日志接口**：设计日志框架的一套标准，日志框架需要实现这些接口

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308300937842.png" alt="image-20230830093726812" style="zoom:80%;" />

> **注意1**：因为对CommonsLogging接口不满意，有人就搞了SLF4J;因为对Log4j的性能不满意，有人就搞了==Logback==
>
> **注意2**：Logback是基于slf4j的日志规范实现的框架

**Logback日志框架有以下几个模块**

1. logback-core：基础模块，是其他两个模块依赖的基础(==必须有==)
2. logback-classic：完整实现了slf4jAPI的模块 (==必须有==)
3. logback-access：与 Tomcat和Jetty 等 Servlet容器集成，以提供HTTP 访问日志的功能(==可选，以后再接触摸==)

**想使用Logback日志框架，至少需要在项目中整合如下三个模块**：

1. slf4j-api: 日志接口
2. logback-core
3. logback-classic

**Logback快速入门**

1.导入Logback框架到项目中去

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308300942509.png" alt="image-20230830094239475" style="zoom:80%;" />

2.将Logback框架的核心配置文件==logback.xml==直接拷贝到src目录下 (必须是src下)

3.创建Logback框架提供的Logger对象，然后用Logger对象调用其提供的方法就可以记录系统的日志信息

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308300945417.png" alt="image-20230830094519369" style="zoom:80%;" />

> **注意**：对Logback日志框架的控制，都是通过其核心配置文件logback.xml来实现的



**核心配置文件logback.xml：**对Logback日志框架进行控制的

**日志的输出位置、输出格式的设置**

通常可以设置2个输出日志的位置：一个是控制台、一个是系统文件中

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308300950851.png" alt="image-20230830095048816" style="zoom:80%;" />

**开启日志(ALL)，取消日志(OFF)**

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308300951485.png" alt="image-20230830095109452" style="zoom:80%;" />



**Logback设置日志级别**

**日志级别**指的是日志信息的类型，日志都会分级别，常见的日志级别如下(优先级依次升高)

| 日志级别 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| trace    | 追踪，指明程序运行轨迹                                       |
| debug    | 调试，实际应用中一般将其作为最低级别，而 trace 则很少使用    |
| info     | 输出重要的运行信息，数据连接、网络连接、10操作等等，使用较多 |
| warn     | 警告信息，可能会发生问题，使用较多                           |
| error    | 错误信息，使用较多                                           |

**设置日志级别**

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308301000081.png" alt="image-20230830100030047" style="zoom:80%;" />

只有日志的级别是大于或等于核心配置文件配置的日志级别，才会被记录，否则不记录



**多线程**

**线程**(Thread)是一个程序内部的一条执行流程

程序中如果只有一条执行流程，那这个程序就是单线程的程序

**多线程**是指从软硬件上实现的多条执行流程的技术(多条线程由CPU负责调度执行)



**在程序中创建出多条线程**

Java是通过java.lang.Thread 类的对象来代表线程的

**1️⃣继承Thread类**

1. 定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法
2. 创建MyThread类的对象

3. 调用线程对象的start()方法启动线程(启动后还是执行run方法的)

> main方法是由一条默认的主线程负责执行

**优点**：编码简单

**缺点**：线程类已经继承Thread，无法继承其他类，不利于功能的扩展

> **多线程的注意事项**：
>
> ​		启动线程必须是调用start方法，不是调用run方法
>
> ​		不要把主线程任务放在启动子线程之前

2️⃣**实现Runnable接口**

1. 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法

2. 创建MyRunnable任务对象

3. 把MyRunnable任务对象交给Thread处理

| Thread类提供的构造器           | 说明                         |
| ------------------------------ | ---------------------------- |
| public Thread(Runnable target) | 封装Runnable对象成为线程对象 |

4. 调用线程对象的start()方法启动线程

**优点**：任务类只是实现接口，可以继续继承其他类、实现其他接口，扩展性强
**缺点**：需要多一个Runnable对象

> 第二种方式的第二种写法 匿名内部类
>
> 1. 可以创建Runnable的匿名内部类对象
> 2. 再交给Thread线程对象
> 3. 再调用线程对象的start()启动线程

3️⃣**利用Callable接口、FutureTask类来实现**

1. 创建任务对象

- 定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据
- 把Callable类型的对象封装成FutureTask (线程任务对象)

2. 把线程任务对象交给Thread对象

3. 调用Thread对象的start方法启动线程

4. 线程执行完毕后、通过FutureTask对象的的get方法去获取线程任务执行的结果

| FutureTask提供的构造器             | 说明                               |
| ---------------------------------- | ---------------------------------- |
| public FutureTask<>(Callable call) | 把Callable对象封装成FutureTask对象 |

| FutureTask提供的方法            | 说明                           |
| ------------------------------- | ------------------------------ |
| public V get() throws Exception | 获取线程执行call方法返回的结果 |

**优点**：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强，可以在线程执行完毕后去获取线程执行的结果。
**缺点**：编码复杂一点。



**Thread的常用方法**

| Thread提供的常用方法                         | 说明                                          |
| -------------------------------------------- | --------------------------------------------- |
| public void run()                            | 线程的任务方法                                |
| public void start()                          | 启动线程                                      |
| public String **getName**()                  | 获取当前线程的名称，线程名称默认是Thread-索引 |
| public void **setName(String name)**         | 为线程设置名称                                |
| public **static** Thread **currentThread()** | 获取当前执行的线程对象                        |
| public **static** void **sleep(long time)**  | 让当前执行的线程休眠多少毫秒后，再继续执行    |
| public final void join()...                  | 让调用当前这个方法的线程先执行完!             |

| Thread提供的常见构造器                      | 说明                                         |
| ------------------------------------------- | -------------------------------------------- |
| public Thread(String name)                  | 可以为当前线程指定名称                       |
| public Thread(Runnable target)              | 封装Runnable对象成为线程对象                 |
| public Thread(Runnable target，String name) | 封装Runnable对象成为线程对象，并指定线程名称 |



**线程安全**

**线程安全问题**：多个线程，同时操作同一个共享资源的时候，可能会出现业务安全问题



**线程同步**：解决线程安全问题的方案

线程同步的思想：让多个线程实现先后依次访问共享资源，这样就解决了安全问题

**线程同步常见方案**：

**加锁**：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来

1️⃣**同步代码块**

1. 作用：把访问共享资源的核心代码给上锁，以此保证线程安全

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308310932636.png" alt="image-20230831093154552" style="zoom:80%;" />

2. 原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行

> 同步锁的注意事项
>
> ​		对于当前同时执行的线程来说，同步锁必须是同一把 (同一个对象)，否则会出bug

**锁对象的使用规范**

- 建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象
- 对于静态方法建议使用字节码 (类名.class)对象作为锁对象

2️⃣**同步方法**

1. 作用：把访问共享资源的核心方法给上锁，以此保证线程安全

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308310938813.png" alt="image-20230831093805772" style="zoom:80%;" />

2. 原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行原理:

3. 同步方法底层原理

- 同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码
- 如果方法是实例方法:同步方法默认用this作为的锁对象
- 如果方法是静态方法:同步方法默认用类名.class作为的锁对象。

> 范围上：同步代码块的范围小（性能较好），同步方法的范围大
>
> 可读性：同步方法更好

3️⃣**Lock锁**

- Lock锁是]DK5开始提供的一个新的锁定操作，通过它可以创建出锁对象进行加锁和解锁，更灵活、更方便、更强大
- Lock是接口，不能直接实例化，可以采用它的实现类ReentrantLock来构建Lock锁对象

| 构造器                 | 说明                   |
| ---------------------- | ---------------------- |
| public ReentrantLock() | 获得Lock锁的实现类对象 |

| 方法名称      | 说明   |
| ------------- | ------ |
| void lock()   | 获得锁 |
| void unlock() | 释锁   |



**线程通信【了解】**

定义：当多个线程共同操作共享的资源时，线程间通过某种方式互相告知自己的状态，以相互协调，并避免无效的资源争夺

**object类的等待和唤醒方法**

| 方法名称         | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| void wait()      | 让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法 |
| void notify()    | 唤醒正在等待的单个线程                                       |
| void notifyAll() | 唤醒正在等待的所有线程                                       |

> 注意：上述方法应该使用当前同步**锁对象进行调用**
>



**线程池**

定义：线程池就是一个可以复用线程的技术

JDK 5.0起提供了代表线程池的接口：ExecutorService

1️⃣使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象

```java
public ThreadPoolExecutor(int corePoolSize int maximumPoolSize, long keepAliveTime, TimeUnit unit,BlockingQueue<Runnable> workQueue， ThreadFactory threadFactory,RejectedExecutionHandler handler)
```

- 参数一：corePoolSize:指定线程池的核心线程的数量
- 参数二：maximumPoolSize:指定线程池的最大线程数量
- 参数三：keepAliveTime: 指定临时线程的存活时间
- 参数四：unit:指定临时线程存活的时间单位(秒、分、时、天)
- 参数五：workQueue:指定线程池的任务队列。
- 参数六：threadFactory:指定线程池的线程工厂
- 参数七：handler:指定线程池的任务拒绝策略(线程都在忙，任务队列也满了的时候，新任务来了该怎么处理)

> **注意事项**：
>
> 1. 临时线程什么时候创建
>
> ​		新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程
>
> 2. 什么时候会开始拒绝新任务
>
> ​		核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝任务

**线程池处理Runnable任务**

| 方法名称                           | 说明                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| **void execute(Runnable command)** | 执行 Runnable任务                                            |
| Future<T>submit(Callable<T>task)   | 执行 Callable 任务，返未来任务对象，用于获取线程返回的结果   |
| void shutdown()                    | 等全部任务执行完毕后，再关闭线程池                           |
| List<Runnable> shutdownNow()       | 立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务 |

**新任务拒绝策略**

| 策略                                   | 详解                                                       |
| -------------------------------------- | ---------------------------------------------------------- |
| ThreadPoolExecutor.AbortPolicy         | 丢弃任务并抛出RejectedExecutionException异常。是默认的策略 |
| ThreadPoolExecutor.DiscardPolicy       | 丢弃任务，但是不抛出异常这是不推荐的做法                   |
| ThreadPoolExecutor.DiscardoldestPolicy | 抛弃队列中等待最久的任务然后把当前任务加入队列中           |
| ThreadPoolExecutor.CallerRunsPolicy    | 由主线程负责调用任务的run()方法从而绕过线程池直接执行      |

**ExecutorService的常用方法**

| 方法名称                               | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| void execute(Runnable command)         | 执行任务/命令，没有返回值，一般用来执行 Runnable 任务        |
| **Future<T> submit(Callable<T> task)** | 执行任务，返回未来任务对象获取线程结果，一般拿来执行 Callable 任务 |
| void shutdown()                        | 等任务执行完毕后关闭线程池                                   |
| List<Runnable> shutdownNow()           | 立刻关闭，停止正在执行的任务，并返回队列中未执行的任务       |

------

### 16. P181 - 190

2️⃣**使用Executors(线程池的工具类)调用方法返回不同特点的线程池对象**

Executors：是一个线程池的工具类，提供了很多静态方法用于返回不同特点的线程池对象

| 方法名称                                                     | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **public static ExecutorService newFixedThreadPool(int nThreads)** | 创建固定线程数量的线程池，如果某个线程因为执行异 常而结束，那么线程池会补充一个新线程替代它 |
| public static ExecutorService newSingleThreadExecutor()      | 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程 |
| public static ExecutorService newCachedThreadPool()          | 线程数量随着任务增加而增加，如果线程任务执行完毕目空闲了60s则会被回收掉 |
| public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) | 创建一个线程池，可以实现在给定的延迟后运行任务或者定期执行任务 |

> 注意：这些方法的底层，都是通过线程池的实现类ThreadPoolExecutor创建的线程池对象
>
> 
>
> 核心线程数量到底配置多少呢？
>
> - 计算密集型的任务:核心线程数 = CPU的核数 + 1
> - IO密集型的任务:核心线程数量 = CPU核数 * 2



**并发、并行**

- 进程：正在运行的程序(软件)就是一个独立的进程
- 线程是属于进程的，一个进程中可以同时运行很多个线程
- ==进程中的多个线程其实是并发和并行执行的==

**并发的含义**

进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发

**并行的理解**

在同一个时刻上，同时有多个线程在被CPU调度执行

**线程的生命周期**

- 也就是线程从生到死的过程中，经历的各种状态及状态转换
- 理解线程这些状态有利于提升并发编程的理解能力

**Java线程的状态**

- Java总共定义了6种状态
- 6种状态都定义在Thread类的内部枚举类中

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308311109000.png" alt="image-20230831110916941" style="zoom:80%;" />

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308311125057.png" alt="image-20230831112518995" style="zoom:80%;" />

| 线程状态                | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| NEW(新建)               | 线程刚被创建，但是并未启动                                   |
| Runnable(可运行)        | 线程已经调用了start()，等待CPU调度                           |
| Blocked(锁阻塞)         | 线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态      |
| Waiting(无限等待)       | 一个线程进入Waiting状态，另一个线程调用notify或者notifyA11方法才能够唤醒 |
| Timed Waiting(计时等待) | 同waiting状态，有几个方法(sleep,wait)有超时参数，调用他们将进入Timed waiting状态 |
| Teminated(被终止)       | 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡 |



**网络编程**

定义：可以让设备中的程序与网络上其他设备中的程序进行数据交互(实现网络通信的)

> java.net.*包下提供了网络编程的解决方案

**基本的通信架构**

基本的通信架构有2种形式: ==CS架构==(Client客户端/Server服务端)、==BS架构==(Browser浏览器/Server服务端)

**网络通信三要素**

1️⃣**IP地址**：设备在网络中的地址，是唯一的标识。

IP (Internet Protocol)：全称”互联网协议地址”，是分配给上网设备的唯一标志

IP地址有两种形式：IPv4、IPv6

**公网IP**：是可以连接互联网的IP地址；**内网IP**：也叫局域网IP，只能组织机构内部使用

192.168.开头的就是常见的局域网地址，范围即为192.168.0.0--192.168.255.255，专门为组织机构内部使用。

**特殊IP地址**

==127.0.0.1、localhos==t: 代表本机IP，只会寻找当前所在的主机

**IP常用命令**:

- ipconfig:查看本机IP地址
- ping IP地址:检查网络是否连通



**InetAddress**：代表IP地址

| InetAddress的常用方法                            | 说明                                             |
| ------------------------------------------------ | ------------------------------------------------ |
| public static InetAddress getLocalHost()         | 获取本机IP，会以一个inetAddress的对象返回        |
| public static InetAddress getByName(String host) | 根据ip地址或者域名，返回一个inetAdress对象       |
| public String getHostName()                      | 获取该ip地址对象对应的主机名                     |
| public String getHostAddress()                   | 获取该ip地址对象中的ip地址信息                   |
| public boolean isReachable(int timeout)          | 在指定毫秒内，判断主机与该ip对应的主机是否能连通 |

2️⃣**端口号**：应用程序在设备中唯一的标识

作用：标记正在计算机设备上运行的应用程序的，被规定为一个16位的二进制，范围是0~65535

**分类**

- 周知端口：0~1023，被预先定义的知名应用占用(如: HTTP占用 80，FTP占用21)
- ==注册端口==：1024~49151，分配给用户进程或某些应用程序
- 动态端口：49152到65535，之所以称为动态端口，是因为它 一般不固定分配某种进程，而是动态分配

> 注意：我们自己开发的程序一般选择使用注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错

3️⃣**协议**：连接和数据在网络中传输的规则。

定义：通信协议-网络上通信的设备，事先规定的连接规则，以及传输数据的规则被称为网络通信协议

**开放式网络互联标准：OSI网络参考模型**

- OSI网络参考模型：全球网络互联标准
- TCP/IP网络模型：事实上的国际标准

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308311427837.png" alt="image-20230831142729760" style="zoom:80%;" />

**传输层的2个通信协议**

1️⃣**UDP(User Datagram Protoco)**：用户数据报协议

UDP协议

特点: 无连接、不可靠通信

​		  不事先建立连接，数据按照包发，一包数据包含:自己的IP、程序端口，目的地IP、程序端口和数据(限制在64KB内)等

​		  发送方不管对方是否在线，数据在中间丢失也不管，如果接收方收到数据也不返回确认，故是不可靠的

2️⃣**TCP(Transmission ontrolProtocol)**: 传输控制协议
特点：面向连接、可靠通信

​		   TCP的最终目的：要保证在不可靠的信道上实现可靠的传输

​		   TCP主要有三个步骤实现可靠传输：三次握手建立连接，传输数据进行确认，四次挥手断开连接

**TCP协议：三次握手建立可靠连接**
		可靠连接：确定通信双方，收发消息都是正常无问题的!(全双工)

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308311438485.png" alt="image-20230831143830427" style="zoom:80%;" />

**TCP协议：四次握手断开连接**
		目的: 确保双方数据的收发都已经完成

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308311441912.png" alt="image-20230831144107851" style="zoom:80%;" />



**UDP通信**

Java提供了一个java.net.DatagramSocket类来实现UDP通信

**DatagramSocket：用于创建客户端、服务端**

| 构造器                          | 说明                                                 |
| ------------------------------- | ---------------------------------------------------- |
| public DatagramSocket()         | 创建==客户端==的socket对象，系统会随机分配一个端口号 |
| public DatagramSocket(int port) | 创建==服务端==的socket对象，并指定端口号             |

| 方法                                      | 说明               |
| ----------------------------------------- | ------------------ |
| public void **send(DatagramPacket dp)**   | 发送数据包         |
| public void **receive(DatagramPacket p)** | 使用数据包接收数据 |

**DatagramPacket：创建数据包**

| 构造器                                                       | 说明                     |
| ------------------------------------------------------------ | ------------------------ |
| public DatagramPacket(bytel] buf,int length, InetAddress address, int port) | 创建发出去的数据包对象   |
| public DatagramPacket(byte[] buf,int length)                 | 创建用来接收数据的数据包 |

| 方法                       | 说明                             |
| -------------------------- | -------------------------------- |
| public int **getLength()** | 获取数据包，实际接收到的字节个数 |

 **UDP通信-多发多收**

放入while循环



**TCP通信**

Java提供了一个java.net.Socket类来实现TCP通信

1️⃣**TCP通信-客户端开发**

客户端程序就是通过java.net包下的Socket类来实现的

| 构造器                               | 说明                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| public Socket(String host ,int port) | 根据指定的服务器ip、端口号请求与服务端建立连接，连接通过，就获得了客户端socket |

| 方法                                  | 说明               |
| ------------------------------------- | ------------------ |
| public OutputStream getOutputStream() | 获得字节输出流对象 |
| public InputStream getInputStream()   | 获得字节输入流对象 |

2️⃣**TCP通信-服务端程序的开发**

服务端是通过java.net包下的ServerSocket类来实现的

| 构造器                        | 说明                 |
| ----------------------------- | -------------------- |
| public ServerSocket(int port) | 为服务端程序注册端口 |

| 方法                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| public Socket accept() | 阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的Socket对象 |

**TCP通信-多发多收**

while    try-catch



**TCP通信-支持与多个客户端同时通信**

新建线程对象

------

### 17. P191 - 200

**Java高级技术**

1️⃣**单元测试**

就是针对最小的功能单元(方法)，编写测试代码对其进行正确性测试

**Junit单元测试框架**

可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了Junit框架，比如IDEA）

**优点**

- 可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立
- 不需要程序员去分析测试的结果，会自动生成测试报告出来

**断言机制**：程序员可以通过预测业务方法的结果`assertEquals(String message, long expected, long actual)`

**Junit单元测试框架的常用注解(unit 4.xxxx版本)**

| 注解         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| @Test        | 测试类中的方法必须用它修饰才能成为测试方法，才能启动执行     |
| @Before      | 用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次 |
| @After       | 用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次 |
| @BeforeClass | 用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次   |
| @AfterClass  | 用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次   |

- 在测试方法执行前执行的方法，常用于：初始化资源
- 在测试方法执行完后再执行的方法，常用于：释放资源

**Junit单元测试框架的常用注解(unit 5.xxxx版本)**

| 注解        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| @Test       | 测试类中的方法必须用它修饰才能成为测试方法，才能启动执行     |
| @BeforeEach | 用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次 |
| @AfterEach  | 用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次 |
| @BeforeAll  | 用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次   |
| @AfterAll   | 用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次   |

- 开始执行的方法：初始化资源
- 执行完之后的方法：释放资源



2️⃣**反射**

反射就是：加载类，并允许以编程的方式解剖类中的各种成分(成员变量、方法、构造器等)

**1.**反射第一步：加载类，获取类的字节码：Class对象

获取Class对象的三种方式：

​		`Class c1=类名.class`

​		调用Class提供方法：`public static Class forName(String package);`

​		Object提供的方法：`public Class getClass(); Class c3= 对象getClass();`

**2.**获取类的构造器：Constructor对象

Class提供了从类中获取构造器的方法

| 方法                                                         | 说明                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| Constructor<?>[] getConstructors()                           | 获取全部构造器(只能获取public修饰的) |
| Constructor<?>[] getDeclaredConstructors()                   | 获取全部构造器(只要存在就能拿到)     |
| Constructor<T> getConstructor(Class<?>... parameterTypes)    | 获取某个构造器(只能获取public修饰的) |
| Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) | 获取某个构造器(只要存在就能拿到)     |

**3.**获取类的成员变量：Field对象

Class提供了从类中获取成员变量的方法

| 方法                                       | 说明                                       |
| ------------------------------------------ | ------------------------------------------ |
| public Field[] getFields()                 | 获取类的全部成员变量(只能获取public修饰的) |
| public Field[] getDeclaredFields()         | 获取类的全部成员变量(只要存在就能拿到)     |
| public Field getField(String name)         | 获取类的某个成员变量(只能获取public修饰的) |
| public Field getDeclaredField(String name) | 获取类的某个成员变量(只要存在就能拿到)     |

获取到成员变量的作用：依然是赋值、取值

| 方法                                    | 说明                                        |
| --------------------------------------- | ------------------------------------------- |
| void set(Object obj,Object value)       | 赋值                                        |
| Object get(Object obj)                  | 取值                                        |
| public void setAccessible(boolean flag) | 设置为true，表示禁止检查访问控制 (暴力反射) |

**4.**获取类的成员方法：Method对象

Class提供了从类中获取成员方法的API

| 方法                                                         | 说明                                       |
| ------------------------------------------------------------ | ------------------------------------------ |
| Method[] getMethods()                                        | 获取类的全部成员方法(只能获取public修饰的) |
| Method[] getDeclaredMethods()                                | 获取类的全部成员方法(只要存在就能拿到)     |
| Method getMethod(String name， Class<?>... parameterTypes)   | 获取类的某个成员方法(只能获取public修饰的) |
| Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 获取类的某个成员方法(只要存在就能拿到)     |

成员方法的作用：依然是执行

| Method提供的方法                                 | 说明                                       |
| ------------------------------------------------ | ------------------------------------------ |
| public object invoke(object obj，Object... args) | 触发某个对象的该方法执行                   |
| public void setAccessible(boolean flag)          | 设置为true，表示禁止检查访问控制(暴力反射) |

**5.**反射的作用、应用场景

- 基本作用：可以得到一个类的全部成分然后操作
- 可以破坏封装性
- ==最重要的用途是：适合做]ava的框架，基本上，主流的框架都会基于反射设计出一些通用的功能==

应用场景：设计通用框架



**注解(Annotation)**

- 定义：就是ava代码里的特殊标记，比如：@Override、@Test等
- 作用：让其他程序根据注解信息来决定怎么执行该程序
- 注意：注解可以用在类上、构造器上、方法上、成员变量上、参数上、等位置处

**1.**自定义注解：自己定义注解

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308311924609.png" alt="image-20230831192438558" style="zoom:80%;" />

**2.**特殊属性名：value

如果注解中只有一个value属性，使用注解时，value名称可以不写!

- 注解本质是一个接口，ava中所有注解都是继承了Annotation接口的
- @注解(...):其实就是一个实现类对象，实现了该注解以及Annotation接口

**3.**元注解：修饰注解的注解

@Target：声明被修饰的注解只能在哪些位置使用

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308311930578.png" alt="image-20230831193057534" style="zoom:80%;" />

@Retention：声明注解的保留周期

<img src="https://csh-picture.oss-cn-shenzhen.aliyuncs.com/img202308311931983.png" alt="image-20230831193137942" style="zoom:80%;" />

**4.**注解的解析：就是判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来

- 指导思想：要解析谁上面的注解，就应该先拿到谁
- 比如要解析类上面的注解，则应该先获取该类的CLass对象，再通过Class对象解析其上面的注解
- 比如要解析成员方法上的注解，则应该获取到该成员方法的Method对象，再通过Method对象解析其上面的注解
- Class、Method、Field,Constructor、都实现了AnnotatedElement接口，它们都拥有解析注解的能力

| AnnotatedElement接口提供了解析注解的方法                     | 说明                           |
| ------------------------------------------------------------ | ------------------------------ |
| public Annotation[] getDeclaredAnnotations()                 | 获取当前对象上面的注解         |
| public T getDeclaredAnnotation(Class<T> annotationClass)     | 获取指定的注解对象             |
| public boolean isAnnotationPresent(Class<Annotation> annotationClass) | 判断当前对象上是否存在某个注解 |

**5.**应用场景：配合反射做框架



**动态代理**

**1.**程序为什么需要代理? 代理长什么样?

（1）对象如果嫌身上干的事太多的话，可以通过代理来转移部分职责

（2）对象有什么方法想被代理，代理就一定要有对应的方法





















